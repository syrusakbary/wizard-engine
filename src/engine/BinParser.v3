// Copyright 2019 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// Parses the binary format of WebAssembly and produces an in-memory module
// representation. The parser uses a "push" model which allows the creator to
// input segments of data into the parser incrementally, e.g. if streaming it
// over a network.
def OUT = Trace.OUT;
class BinParser(extensions: Extension.set, limits: Limits, filename: string) {
	def err = ErrorGen.new(filename);
	def module = Module.new(filename);
	var validate_code = true;
	var validator: CodeValidator;
	var parser: WasmParser;

	private var fsm: BpFsm;
	private var seen_sections = Array<bool>.new(BpSection.Data.tag + 3);
	private var declared_func_count: u32;
	private var func_body_cursor: int;

	new() {
		var callback = BinParserCallback.new(this);
		fsm = BpFsm.new(extensions, limits, err, callback);
		parser = WasmParser.new(extensions, limits, module, err, fsm.decoder);
	}

	// Push new data into the parser from the specified range. The given
	// array is not modified or retained by this call; internal copies of
	// data are made if necessary. However, do not pass an array that could
	// be concurrently modified, as it may be decoded in place.
	def push(x: Array<byte>, xpos: int, xlength: int) -> this {
		if (xlength == 0) return; // nothing to do
		if (err.error()) return;  // already hit an error
		fsm.push(x, xpos, xlength);
	}
	// Finish the decoding of the pushed bytes, returning a valid module
	// upon success, or an error.
	def finish() -> BinParserResult {
		var func_count = declared_func_count;
		if (func_count > 0 && !seen_sections[BpSection.Code.code]) {
			err.at(parser.decoder).MissingCodeSection(func_count);
		}
		var data_count = module.explicit_data_count;
		if (data_count > 0 && !seen_sections[BpSection.Data.code]) {
			err.at(parser.decoder).MissingDataSection(data_count);
		}
		return fsm.finish();
	}

	def decodeSection(kind: BpSection, size: u32, d: DataReader) {
		var start = d.pos;
		parser.decoder = d;
//		parser.debugBuffer();
		if (kind != BpSection.Unknown) {
			if (seen_sections[kind.code]) {
				if (!extensions.REPEAT_SECTIONS) return err.rel(d, d.pos-1).DuplicateSection(kind);
			} else {
				seen_sections[kind.code] = true;
			}
		}
		err.section = kind;
		match (kind) {
			Unknown => readCustomSection(size);
			Type => {
				var count = parser.readCountAndReserve("types", module.heaptypes, limits.max_num_types);
				readLoop("type", count, WasmParser.readDefType);
			}
			Import => {
				var count = parser.readCountAndReserve("imports", module.imports, limits.max_num_imports);
				readLoop("imports", count, WasmParser.readImportDecl);
			}
			Function => {
				var count = parser.readCountAndReserve("functions", module.functions, limits.max_num_functions);
				declared_func_count = count;
				readLoop("functions", count, WasmParser.readFuncDecl);
			}
			Table => {
				var count = parser.readCountAndReserve("tables", module.tables, limits.max_num_tables);
				readLoop("tables", count, WasmParser.readTableDecl);
			}
			Memory => {
				var count = parser.readCountAndReserve("memories", module.memories, limits.max_num_memories);
				readLoop("memories", count, WasmParser.readMemoryDecl);
			}
			Global => {
				var count = parser.readCountAndReserve("globals", module.globals, limits.max_num_globals);
				readLoop("globals", count, WasmParser.readGlobalDecl);
			}
			Export => {
				var count = parser.readCountAndReserve("exports", module.exports, limits.max_num_exports);
				var set = StringSet.new(int.!(count));
				readLoop("exports", count, WasmParser.readExportDecl(_, _, set));
			}
			Data => {
				var pos = parser.decoder.pos;
				var count = parser.readCountAndReserve("data segments", module.data, limits.max_num_data_segments);
				if (module.explicit_data_count >= 0 && count != module.explicit_data_count) {
					return err.rel(parser.decoder, pos).DataCountMismatch(module.explicit_data_count, count);
				}
				readLoop("data segments", count, WasmParser.readDataDecl);
			}
			Element => {
				var count = parser.readCountAndReserve("elements", module.elems, limits.max_num_table_entries);
				readLoop("elements", count, WasmParser.readElemDecl);
			}
			Start => readStartSection();
			DataCount => readDataCountSection();
			_ => return err.at(d).InvalidSectionCode(kind.code);
		}
		err.section = BpSection.Unknown;
		var read = d.pos - start;
		if (read < size) {
			err.at(d).IncompleteSection(kind.code, read, size);
		}
	}
	def beginCodeSection(abspos: int, count: u32) {
		var kind = BpSection.Code;
		if (seen_sections[kind.code]) {
			if (!extensions.REPEAT_SECTIONS) return err.abs(abspos - 1).DuplicateSection(kind);
		} else {
			seen_sections[kind.code] = true;
			if (count != declared_func_count) {
				// TODO: count >= remaining_func_count ?
				err.abs(abspos).FuncCountMismatch(declared_func_count, count);
			}
		}
	}
	def readCustomSection(size: u32) {
		var decoder = parser.decoder;
		var start = decoder.pos;
		var name = parser.readUtf8String("custom section name");
		var payload_len = int.!(size) - (decoder.pos - start);
		if (payload_len < 0) {
			return err.rel(decoder, start).CustomSectionNameLengthTooLong(name.length, size);
		}
		var payload = decoder.readN(payload_len);
		module.custom_sections.put(CustomSection.new(name, payload));
		if (Strings.equal("name", name)) module.names = NameSection.new(module, payload);
	}
	def readLoop(thing_name: string, count: u32, read: (WasmParser, int) -> void) {
		var p = parser;
		for (i < int.!(count)) {
			if (err.error()) break;
			err.index = i;
			if (Trace.binparse) OUT.put2("==>%s #%d", thing_name, i).outln();
			read(p, i);
		}
	}
	def readStartSection() {
		var decoder = parser.decoder;
		var pt = decoder.pos;
		var f = parser.readFuncRef();
		if (f != null) {
			module.start_function = f.func_index;
			var sig = f.sig;
			if (sig.params.length > 0 || sig.results.length > 0) {
				err.rel(decoder, pt).IllegalStartFunctionType(sig);
			}
		}
	}
	def readDataCountSection() {
		var count = parser.readU32("data count", limits.max_num_data_segments);
		if (count < limits.max_grow_size) module.data.grow(int.!(count));
		module.explicit_data_count = int.!(count);
	}
	def decodeFunctionBody(index: u32, size: u32, decoder: DataReader) {
		if (Trace.binparse) OUT.put1("==>body #%d", func_body_cursor).outln();
		parser.decoder = decoder;
		var start = decoder.pos;
		var f: FuncDecl, i = func_body_cursor;
		err.section = BpSection.Code;
		err.index = i;
		while (true) {
			if (i >= module.functions.length) {
				err.at(decoder).FuncCountMismatch(declared_func_count, index);
				return;
			}
			f = module.functions[i++];
			if (!f.imported()) break;
		}
		func_body_cursor = i;
		var body = decoder.readN(int.!(size));
		decoder.at(start);
		f.code = Code.new(body);
		if (!validate_code) return;
		if (validator == null) validator = CodeValidator.new(extensions, limits, module, err);
		validator.validate(f, decoder);
	}
}

class BinParserCallback(mp: BinParser) extends BpFsmCallback(mp.module) {
	def decodeSection(kind: BpSection, size: u32, d: DataReader) {
		mp.decodeSection(kind, size, d);
	}
	def beginCodeSection(abspos: int, count: u32) {
		mp.beginCodeSection(abspos, count);
	}
	def decodeFunctionBody(index: u32, size: u32, d: DataReader) {
		mp.decodeFunctionBody(index, size, d);
	}
}

type BinParserResult {
	case Ok(module: Module) { }
	case Error(code: WasmError, filename: string, section: BpSection, error_index: int, error_pos: int, error_msg: string) { }
}

// Contains common routines for the module parser and function body parser.
class WasmParser(extensions: Extension.set, limits: Limits, module: Module,
	err: ErrorGen, var decoder: DataReader) {
	def cache = Canon.globalCache;
	var eof = false;
	var init_stack: ArrayStack<(ValueType, InitExpr)>;
	var max_fw_index = if(module != null, module.heaptypes.length);
	var max_legal_index = max_fw_index;

	def eof_set_flag(d: DataReader, pos: int, size: int, msg: string) {
		eof = true;
	}
	def reset(d: DataReader) {
		this.decoder = d;
		max_fw_index = max_legal_index = module.heaptypes.length;
	}
	def readTableRef() -> TableDecl {
		return readIndex("table", module.tables);
	}
	def readTableIndex() -> int {
		return readAndCheckIndex("table", module.tables.length).1;
	}
	def readTableImm() -> int {
		return readTableIndex();
	}
	def readSigRef() -> SigDecl {
		var pt = decoder.pos;
		var ht = readIndex("signature", module.heaptypes);
		if (SigDecl.?(ht)) return SigDecl.!(ht);
		err.rel(decoder, pt).ExpectedSignature(ht);
		return null;
	}
	def readSigIndex() -> int {
		var pt = decoder.pos;
		var t = readAndCheckIndex("signature", module.heaptypes.length);
		if (t.0) {
			var ht = module.heaptypes[t.1];
			if (!SigDecl.?(ht)) err.rel(decoder, pt).ExpectedSignature(ht);
			return t.1;
		}
		return 0;
	}
	def readFuncRef() -> FuncDecl {
		return readIndex("function", module.functions);
	}
	def readFuncIndex() -> int {
		return readAndCheckIndex("function", module.functions.length).1;
	}
	def readMemoryRef() -> MemoryDecl {
		return readIndex("memory", module.memories);
	}
	def readMemoryIndex() -> int {
		return readAndCheckIndex("memory", module.memories.length).1;
	}
	def readDataIndex() -> int {
		var max = module.data.length, ex = module.explicit_data_count;
		if (ex > max) max = ex;
		return readAndCheckIndex("data", max).1;
	}
	def readElemRef() -> ElemDecl {
		return readIndex("elem", module.elems);
	}
	def readMemoryImm() -> int {
		var pt = decoder.pos;
		if (extensions.MULTI_MEMORY) {
			return readMemoryIndex();
		} else {
			var b = readByte("memory index", StringBuilder.putd);
			if (b != 0) err.rel(decoder, pt).ExpectedMemoryIndexZeroByte(b);
			checkIndex(pt, "memory", 0, module.memories.length);
			return 0;
		}
	}
	def readGlobalRef() -> GlobalDecl {
		return readIndex("global", module.globals);
	}
	def readAbsTypeRef() -> AbsTypeDecl {
		return readIndex("abstract type", module.abstypes);
	}
	def readIndex<T>(quantity: string, space: Vector<T>) -> T {
		var t = readAndCheckIndex(quantity, space.length);
		return if(t.0, space[t.1]);
	}
	def readAndCheckIndex(quantity: string, max: int) -> (bool, int) {
		var pt = decoder.pos;
		var index = decoder.read_uleb32();
		if (Trace.binparse) {
			traceBytes(pt, quantity);
			OUT.putd(index).outln();
		}
		return checkIndex(pt, quantity, index, max);
	}
	def checkIndex(pt: int, quantity: string, index: u32, max: int) -> (bool, int) {
		if (index >= max) {
			err.rel(decoder, pt).OobIndex(quantity, index, u32.!(max));
			return (false, int.!(index));
		}
		return (true, int.!(index));
	}
	def readValueType() -> ValueType {
		var pt = decoder.pos, code = readTypeCode();
		return readValueTypeSuffix(pt, code);
	}
	def readValueTypeSuffix(pt: int, code: int) -> ValueType {
		match (code) {
			BpTypeCode.I32.val => return ValueType.I32;
			BpTypeCode.I64.val => return ValueType.I64;
			BpTypeCode.F32.val => return ValueType.F32;
			BpTypeCode.F64.val => return ValueType.F64;
			BpTypeCode.V128.val => return ValueType.V128;
			BpTypeCode.FUNCREF.val => return ValueTypes.FUNCREF;
			BpTypeCode.EXTERNREF.val => {
				if (extensions.GC) return ValueTypes.ANYREF; // TODO: ugly
				return ValueTypes.EXTERNREF;
			}
			BpTypeCode.ANYREF.val => if (extensions.GC) {
				return ValueTypes.ANYREF;
			}
			BpTypeCode.REF.val => {
				var heap = readHeapType1();
				return ValueType.Ref(false, heap);
			}
			BpTypeCode.REF_NULL.val => {
				var heap = readHeapType1();
				return ValueType.Ref(true, heap);
			}
			BpTypeCode.DATAREF.val => if (extensions.GC) {
				return ValueTypes.DATAREF;
			}
			BpTypeCode.I31REF.val => if (extensions.GC) {
				return ValueTypes.I31REF;
			}
			BpTypeCode.ARRAYREF.val => if (extensions.GC) {
				return ValueTypes.ARRAYREF;
			}
			BpTypeCode.NONEREF.val => if (extensions.GC) {
				return ValueTypes.NONEREF;
			}
			BpTypeCode.RTT.val => {
				var depth = readU32("rtt depth", limits.max_rtt_depth);
				var pt = decoder.pos;
				var index = readU32("type index", u32.max);
				var def_length = u32.view(module.heaptypes.length);
				if (index >= def_length) {
					err.rel(decoder, pt).OobIndex("type index", index, def_length);
					return ValueType.I32;
				}
				return ValueType.Ref(false, HeapType.Rtt(int.!(depth), module.heaptypes[int.view(index)]));
			}
			BpTypeCode.ABS.val => if (extensions.TYPE_IMPORTS) {
				var pt = decoder.pos;
				var at = readIndex("type", module.abstypes);
				if (at != null) return ValueType.Abstract(at);
				return ValueType.I32;
			}
		}

		err.rel(decoder, pt).InvalidValueTypecon(code);
		return ValueType.I32;
	}
	def readRefType(isTable: bool) -> ValueType {
		var pt = decoder.pos, code = readTypeCode();
		match (code) {
			BpTypeCode.FUNCREF.val => return ValueTypes.FUNCREF;
			BpTypeCode.EXTERNREF.val => {
				if (extensions.GC) return ValueTypes.ANYREF;
				return ValueTypes.EXTERNREF;
			}
			BpTypeCode.ANYREF.val => return ValueTypes.ANYREF;
			BpTypeCode.DATAREF.val => return ValueTypes.DATAREF;
			BpTypeCode.ARRAYREF.val => return ValueTypes.ARRAYREF;
			BpTypeCode.NONEREF.val => return ValueTypes.NONEREF;
			BpTypeCode.EQREF.val => return ValueTypes.EQREF;
			BpTypeCode.REF.val => return ValueType.Ref(false, readHeapType1());
			BpTypeCode.REF_NULL.val => return ValueType.Ref(true, readHeapType1());
		}
		if (isTable) err.rel(decoder, pt).IllegalTableElementType(code);
		else err.rel(decoder, pt).InvalidRefTypecon(code);
		return ValueType.I32;
	}
	def readRefNullType() -> ValueType {
		var heap = readHeapType1();
		return ValueType.Ref(true, heap);
	}
	def readHeapType1() -> HeapType {
		var pt = decoder.pos;
		var index = readTypeCode();
		match (index) { // TODO: check extension set
			BpHeapTypeCode.FUNC.val => return HeapType.Func(null);
			BpHeapTypeCode.EXTERN.val => {
				if (extensions.GC) return HeapType.ANY;
				return HeapType.EXTERN;
			}
			BpHeapTypeCode.ANY.val => return HeapType.ANY;
			BpHeapTypeCode.EQ.val => if (extensions.GC) return HeapType.EQ;
			BpHeapTypeCode.I31.val => if (extensions.GC) return HeapType.I31;
			BpHeapTypeCode.DATA.val => if (extensions.GC) return HeapType.DATA;
			BpHeapTypeCode.ARRAY.val => if (extensions.GC) return HeapType.Array(null);
			BpHeapTypeCode.NONE.val => if (extensions.GC) return HeapType.NONE;
			BpHeapTypeCode.RTTN.val => if (extensions.GC) {
				var depth = readU32("rtt depth", u31.max);
				var index = readU32("heap type", u32.view(module.heaptypes.length));
				return HeapType.Rtt(int.view(depth), module.heaptypes[int.view(index)]); // TODO: fwref, check bounds
			}
			BpHeapTypeCode.RTT.val => if (extensions.GC) {
				var depth = -1;
				var index = readU32("heap type", u32.view(module.heaptypes.length));
				return HeapType.Rtt(depth, module.heaptypes[int.view(index)]); // TODO: check bounds
			}
		}
		var NONE: Extension.set;
		if (index < 0 || (extensions & (Extension.FUNCTION_REFERENCES | Extension.GC)) == NONE) {
			err.rel(decoder, decoder.pos - 1).InvalidHeapType(index);
			return HeapType.ANY;
		}
		return toHeapType(pt, index);
	}
	def toHeapType(pt: int, index: int) -> HeapType {
		if (index >= max_legal_index) {
			err.rel(decoder, pt).OobIndex("heap type", u32.view(index), u32.view(max_legal_index));
			return HeapType.ANY;
		}
		if (index >= max_fw_index) {
			return HeapType.FwRef(index - max_fw_index);
		}
		match (module.heaptypes[index]) {
			x: StructDecl => return HeapType.Struct(x);
			x: SigDecl => return HeapType.Func(x);
			x: ArrayDecl => return HeapType.Array(x);
			_ => return HeapType.ANY;
		}
	}
	def readHeapType() -> HeapTypeDecl {
		return readIndex("type index", module.heaptypes);
	}
	def readStructType() -> StructDecl {
		var pt = decoder.pos;
		var ht = readIndex("struct", module.heaptypes);
		if (StructDecl.?(ht)) return StructDecl.!(ht);
		err.rel(decoder, pt).ExpectedStructType(ht);
		return null;
	}
	def readFieldIndex(sdecl: StructDecl) -> int {
		var pt = decoder.pos;
		var index = readU32("field index", limits.max_num_struct_fields);
		if (sdecl == null) return -1;
		var max = u32.view(sdecl.field_types.length);
		if (index >= max) {
			err.rel(decoder, pt).OobIndex("field index", index, max);
			return -1;
		}
		return int.view(index);
	}
	def readArrayType() -> ArrayDecl {
		var pt = decoder.pos;
		var ht = readIndex("array", module.heaptypes);
		if (ArrayDecl.?(ht)) return ArrayDecl.!(ht);
		err.rel(decoder, pt).ExpectedArrayType(ht);
		return null;
	}
	def readU32(quantity: string, max: u32) -> u32 {
		var pt = decoder.pos;
		var val = decoder.read_uleb32();
		if (eof) return 0;
		if (val > max) err.rel(decoder, pt).QuantityExceededMaximum(quantity, val, max);
		if (Trace.binparse) {
			traceBytes(pt, quantity);
			OUT.putd(val).outln();
		}
		return val;
	}
	def readUtf8String(quantity: string) -> string {
		var len = readU32("string length", limits.max_module_size);
		var pt = decoder.pos;
		var str = decoder.readN(int.!(len));
		if (Trace.binparse) {
			traceBytes(pt, quantity);
			OUT.puts("\"");
			var max = 24;
			var count = decoder.pos - pt;
			for (i = 0; i < count && i < max; i++) {
				OUT.put1("%c", toPrintableChar(decoder.data[pt + i]));
			}
			OUT.puts("\"").outln();
		}
		if (!Utf8.validate(str)) err.rel(decoder, pt).InvalidUtf8String();
		return str;
	}
	def readByte(quantity: string, render: (StringBuilder, byte) -> StringBuilder) -> byte {
		var pt = decoder.pos;
		var r = decoder.read1();
		if (Trace.binparse) {
			traceBytes(pt, quantity);
			OUT.put2("%d (%q)", r, render(_, r)).outln();
		}
		return r;
	}
	def readBlockType() -> SigDecl {
		var pt = decoder.pos, code = readTypeCode();
		match (code) {
			BpTypeCode.EmptyBlock.val => return SigCache.v_v;
			BpTypeCode.I32.val => return SigCache.v_i;
			BpTypeCode.I64.val => return SigCache.v_l;
			BpTypeCode.F32.val => return SigCache.v_f;
			BpTypeCode.F64.val => return SigCache.v_d;
			BpTypeCode.V128.val => return SigCache.v_s;
			BpTypeCode.FUNCREF.val => return SigCache.v_g;
			BpTypeCode.EXTERNREF.val => {
				if (extensions.GC) return SigCache.v_r;
				return SigCache.v_e;
			}
			BpTypeCode.ANYREF.val => return SigCache.v_r;
			BpTypeCode.REF.val => {
				var heap = readHeapType1();
				var vt = ValueType.Ref(false, heap);
				return Canon.sigPR(SigCache.arr_v, [vt]);
			}
			BpTypeCode.REF_NULL.val => {
				var heap = readHeapType1();
				var vt = ValueType.Ref(true, heap);
				return Canon.sigPR(SigCache.arr_v, [vt]);
			}
			BpTypeCode.I31REF.val => if (extensions.GC) {
				return SigCache.v_h;
			}
			BpTypeCode.DATAREF.val => if (extensions.GC) {
				return Canon.sigPR(SigCache.arr_v, [ValueTypes.DATAREF]); // XXX: cache
			}
			BpTypeCode.ARRAYREF.val => if (extensions.GC) {
				return Canon.sigPR(SigCache.arr_v, [ValueTypes.ARRAYREF]); // XXX: cache
			}
			BpTypeCode.NONEREF.val => if (extensions.GC) {
				return Canon.sigPR(SigCache.arr_v, [ValueTypes.NONEREF]); // XXX: cache
			}
			BpTypeCode.ABS.val => if (extensions.TYPE_IMPORTS) {
				var pt = decoder.pos;
				var at = readIndex("type", module.abstypes);
				if (at != null) return Canon.sigPR(SigCache.arr_v, [ValueType.Abstract(at)]);
				return SigCache.v_v;
			}
		}
		decoder.at(pt); // backup and try again as full signed LEB
		var index = decoder.read_sleb32();
		if (index >= 0 && index < module.heaptypes.length) {
			match (module.heaptypes[index]) {
				x: SigDecl => return x;
			}
		}
		err.rel(decoder, pt).InvalidBlockType(index);
		return SigCache.v_v;
	}
	def readLabel() -> u32 {
		var depth = decoder.read_uleb32();
		return depth;
	}
	def readLabels() -> Array<u32> {
		var pt = decoder.pos;
		var count = decoder.read_uleb32(), max = limits.max_func_size;
		if (count > max) {
			err.rel(decoder, pt).QuantityExceededMaximum("label count", count, max);
			return null;
		}
		var length = int.!(count + 1);
		var result = Array<u32>.new(length);
		for (i < length) result[i] = decoder.read_uleb32();
		return result;
	}
	def readLocalIndex() -> u32 {
		var index = decoder.read_uleb32();
		return index;
	}
	def readMemoryArg() -> (u32, int, u32) {
		var pt = decoder.pos;
		var flags = readU32("memarg flags", u32.max); // TODO render
		var mem_index = 0;
		if (extensions.MULTI_MEMORY && ((flags & BpConstants.MEMARG_INDEX_FLAG)) != 0) {
			mem_index = readMemoryIndex();
			flags ^= 0x40;  // flip flag back
		} else {
			checkIndex(pt, "memory", 0, module.memories.length);
		}
		var offset = readU32("memarg offset", u32.max);
		return (flags, mem_index, offset);
	}
	def readTypeCode() -> i32 {
		var pt = decoder.pos;
		var val = decoder.read_sleb32();
		if (Trace.binparse) {
			var str = "unknown";
			match (val) {
				BpTypeCode.I32.val => str = "i32";
				BpTypeCode.I64.val => str = "i64";
				BpTypeCode.F32.val => str = "f32";
				BpTypeCode.F64.val => str = "f64";
				BpTypeCode.V128.val => str = "v128";
				BpTypeCode.I8.val => str = "i8";
				BpTypeCode.I16.val => str = "i16";
				BpTypeCode.FUNCREF.val => str = "ref func";
				BpTypeCode.EXTERNREF.val => str = "ref extern";
				BpTypeCode.ANYREF.val => str = "ref any";
				BpTypeCode.EQREF.val => str = "ref eq";
				BpTypeCode.EmptyBlock.val => str = "empty block type";
				BpTypeCode.REF_NULL.val => str = "ref null <T>";
				BpTypeCode.REF.val => str = "ref <T>";
				BpTypeCode.I31REF.val => str = "ref i31";
				BpTypeCode.RTTN.val => str = "rtt <N> <T>";
				BpTypeCode.RTT.val => str = "rtt <T>";
				BpTypeCode.DATAREF.val => str = "ref data";
				BpTypeCode.ARRAYREF.val => str = "ref array";
				BpTypeCode.NONEREF.val => str = "ref none";
				BpTypeCode.ABS.val => str = "abstract type";
			}
			traceBytes(pt, "type code");
			OUT.putd(val).put1(" (%s)", str).outln();
		}
		return val;
	}
	def readI32() -> i32 {
		var pt = decoder.pos;
		var val = decoder.read_sleb32();
		if (Trace.binparse) {
			traceBytes(pt, "i32 leb");
			OUT.putd(val).outln();
		}
		return val;
	}
	def readI64() -> i64 {
		var pt = decoder.pos;
		var val = decoder.read_sleb64();
		if (Trace.binparse) {
			traceBytes(pt, "i64 leb");
			OUT.putd(val).outln();
		}
		return val;
	}
	def readF32() -> u32 {
		var pt = decoder.pos;
		var val = decoder.read_u32();
		if (Trace.binparse) {
			traceBytes(pt, "f32 bytes");
			OUT.outln();
		}
		return val;
	}
	def readF64() -> u64 {
		var pt = decoder.pos;
		var val = decoder.read_u64();
		if (Trace.binparse) {
			traceBytes(pt, "f64 bytes");
			OUT.outln();
		}
		return val;
	}
	def readTableLimits() -> (u32, Max) {
		var pt = decoder.pos;
		var flags = readByte("table flags", BpConstants.renderTableFlags);
		if ((flags & ~(limits.ok_table_flags)) != 0) err.rel(decoder, pt).InvalidTableFlags(flags);
		var initial = readU32("initial", limits.max_num_table_entries);
		var has_max = (flags & BpMemoryFlag.HasMax.mask) != 0;
		var max: Max = Max.None;
		if (has_max) {
			var pt = decoder.pos;
			var val = readU32("maximum", limits.max_num_table_entries);
			if (val < initial) err.rel(decoder, pt).MaximumLessThanInitial("table", val, initial);
			max = Max.Set(val);
		}
		return (initial, max);

	}
	def readMemoryLimits() -> (u32, Max, bool) {
		var pt = decoder.pos;
		var flags = readByte("memory flags", BpConstants.renderMemoryFlags);
		if ((flags & ~(limits.ok_memory_flags)) != 0) err.rel(decoder, pt).InvalidMemoryFlags(flags);
		var initial = readU32("initial", limits.max_memory_pages);
		var has_max = (flags & BpMemoryFlag.HasMax.mask) != 0;
		var max: Max = Max.None;
		if (has_max) {
			var pt = decoder.pos;
			var val = readU32("maximum", limits.max_memory_pages);
			if (val < initial) err.rel(decoder, pt).MaximumLessThanInitial("memory", val, initial);
			max = Max.Set(val);
		}
		var shared = (flags & BpMemoryFlag.Shared.mask) != 0;
		if (shared && !has_max) err.rel(decoder, pt).ExpectedSharedMemoryMaximum();
		return (initial, max, shared);
	}
	def readElemType() -> ValueType {
		return readRefType(true);
	}
	def readI32Expr(quantity: string) -> InitExpr {
		return readInitExpr(quantity, ValueType.I32);
	}
	def readInitExpr(quantity: string, expected: ValueType) -> InitExpr {
		// TODO: reduce duplication with CodeValidator
		if (init_stack == null) init_stack = ArrayStack.new();
		else init_stack.clear();
		var wasEnd = false;
		var pt = decoder.pos;
		var last: byte;
		while (decoder.pos < decoder.limit) {
			pt = decoder.pos;
			last = readByte("opcode", Opcodes.render);
			match (last) {
				Opcode.I32_CONST.code => {
					var val = readI32();
					init_stack.push(ValueType.I32, InitExpr.I32(int.view(val)));
				}
				Opcode.I64_CONST.code => {
					var val = readI64();
					init_stack.push(ValueType.I64, InitExpr.I64(long.view(val)));
				}
				Opcode.F32_CONST.code => {
					var val = decoder.read_u32();
					init_stack.push(ValueType.F32, InitExpr.F32(val));
				}
				Opcode.F64_CONST.code => {
					var val = decoder.read_u64();
					init_stack.push(ValueType.F64, InitExpr.F64(val));
				}
				Opcode.REF_NULL.code => {
					init_stack.push(readRefNullType(), InitExpr.ExternRefNull);
				}
				Opcode.REF_FUNC.code => {
					var f = readFuncRef();
					if (f != null) {
						f.reffed = true;
						init_stack.push(ValueTypes.RefFunc(false, f.sig), InitExpr.FuncRef(f.func_index, f));
					}
				}
				Opcode.GLOBAL_GET.code => {
					var g = readGlobalRef();
					if (g != null) {
						if (g.mutable) err.rel(decoder, pt).ExpectedImmutableGlobalInInit(g);
						init_stack.push(g.valtype, InitExpr.Global(g.global_index, g));
					}
				}
				Opcode.END.code => {
					break;
				}
				0xFB => if (extensions.GC) {
					var b2 = readU32("opcode", 1024);
					match (b2) {
						Opcode.STRUCT_NEW_WITH_RTT.code => {
							var st = readStructType();
							if (st == null) break;
							var rtt = init_stack.pop().1; // TODO: typecheck
							var vals = Array<InitExpr>.new(st.field_types.length);
							for (i < vals.length) {
								vals[i] = init_stack.pop().1; // TODO: typecheck
							}
							var ht = HeapType.Struct(st);
							init_stack.push(ValueType.Ref(false, ht), InitExpr.Struct(ht, vals, rtt));
						}
						Opcode.STRUCT_NEW_DEFAULT_WITH_RTT.code => {
							var st = readStructType();
							if (st == null) break;
							var rtt = init_stack.pop().1; // TODO: typecheck
							var vals = Array<InitExpr>.new(st.field_types.length); // TODO: proper default values
							var ht = HeapType.Struct(st);
							init_stack.push(ValueType.Ref(false, ht), InitExpr.Struct(ht, vals, rtt));
						}
						Opcode.ARRAY_NEW_WITH_RTT.code => {
							var at = readArrayType();
							if (at == null) break;
							var rtt = init_stack.pop().1; // TODO: typecheck
							var len = init_stack.pop().1; // TODO: typecheck
							var elem = init_stack.pop().1; // TODO: typecheck
							var ht = HeapType.Array(at);
							init_stack.push(ValueType.Ref(false, ht), InitExpr.Array(ht, len, elem, rtt));
						}
						Opcode.ARRAY_NEW_DEFAULT_WITH_RTT.code => {
							var at = readArrayType();
							if (at == null) break;
							var rtt = init_stack.pop().1; // TODO: typecheck
							var len = init_stack.pop().1; // TODO: typecheck
							var elem: InitExpr;
							match (at.elem_types[0].valtype) {
								I32 => elem = InitExpr.I32(0);
								I64 => elem = InitExpr.I64(0);
								F32 => elem = InitExpr.F32(0);
								F64 => elem = InitExpr.F64(0);
								V128 => elem = InitExpr.V128(0, 0);
								BOTTOM, Ref, Abstract, Host => elem = InitExpr.ExternRefNull;
							}
							var ht = HeapType.Array(at);
							init_stack.push(ValueType.Ref(false, ht), InitExpr.Array(ht, len, elem, rtt));
						}
						Opcode.ARRAY_NEW_FIXED.code => {
							var at = readArrayType();
							var length = decoder.read_uleb32();
							var vals = Array<InitExpr>.new(int.!(length));
							var rtt = init_stack.pop().1; // TODO: typecheck
							for (i = vals.length - 1; i >= 0; i--) vals[i] = init_stack.pop().1;
							var ht = HeapType.Array(at);
							init_stack.push(ValueType.Ref(false, ht), InitExpr.FixedArray(ht, vals, rtt));
						}
						Opcode.I31_NEW.code => {
							var e = init_stack.pop();
							if (e.0 == ValueType.I32) {
								init_stack.push(ValueTypes.I31REF_NONNULL, InitExpr.I31(e.1));
							} else {
								err.rel(decoder, pt).TypeMismatchIn(Strings.format1("i31.new in %s", quantity), ValueType.I32, e.0);
							}
						}
						Opcode.RTT_CANON.code => {
							var t1 = readHeapType();
							var vt = ValueType.Ref(false, HeapType.Rtt(1, t1));
							init_stack.push(vt, InitExpr.Const(Value.Ref(Canon.getRtt(t1))));
						}
						_ => err.rel(decoder, pt).UnexpectedOpcodeInInit(last, b2);
					}
				}
				0xFD => {
					var b2 = decoder.read_uleb32();
					match (Opcodes.page_FD[b2]) {
						V128_CONST => {
							decoder.skipN(16); // TODO: read v128 const initializer
							init_stack.push(ValueType.V128, InitExpr.V128(0, 0));
						}
						_ => err.rel(decoder, pt).UnexpectedOpcodeInInit(last, b2);
					}
				}
				_ => {
					err.rel(decoder, pt).UnexpectedOpcodeInInit(0, last);
				}
			}
		}
		if (last != Opcode.END.code) err.rel(decoder, pt).ExpectedEndInInit(0);
		if (init_stack.top != 1) {
			err.rel(decoder, decoder.pos).TypeMismatchIn(quantity, expected, ValueType.BOTTOM); // TODO: proper msg for multiple
			return InitExpr.ExternRefNull;
		} else {
			var t = init_stack.pop();
			if (!ValueTypes.isAssignable(t.0, expected)) err.rel(decoder, decoder.pos).TypeMismatchIn(quantity, expected, t.0);
			return t.1;
		}
	}
	def readDefType(index: int) {
		var recgrp_start = module.heaptypes.length;
		max_fw_index = recgrp_start;
		var pt = decoder.pos;
		var code = readByte("deftype code", BpConstants.renderDefTypeCode); // XXX: LEB not allowed here
		if (extensions.GC) {
			var count = 1;
			if (code == BpDefTypeCode.REC.code) { // parse as a recursion group
				count = int.!(readU32("recursion group count", limits.max_num_types));
				max_legal_index = recgrp_start + count;
				for (i < count) readDefType2(true, ValueTypes.NO_HEAPTYPES);
			} else { // treat as a single type in its own recursion group
				max_legal_index = recgrp_start + count;
				readDefType3(true, pt, code, ValueTypes.NO_HEAPTYPES);
			}
			if (err.ok()) {
				cache.doGroup(module.heaptypes, recgrp_start, count);
				max_fw_index = max_legal_index = module.heaptypes.length;
			}
		} else {
			// parse a single type
			max_legal_index = max_fw_index;
			readDefType3(false, pt, code, ValueTypes.NO_HEAPTYPES);
			if (err.ok()) {
				var i = module.heaptypes.length - 1;
				module.heaptypes[i] = cache.doOne(module.heaptypes[i]);
				max_fw_index = max_legal_index = module.heaptypes.length;
			}
		}
	}
	def readDefType2(subok: bool, supertypes: Array<HeapType>) {
		var pt = decoder.pos;
		var code = readByte("deftype code", BpConstants.renderDefTypeCode); // XXX: LEB not allowed here
		readDefType3(subok, pt, code, supertypes);
	}
	def readDefType3(subok: bool, pt: int, code: byte, supertypes: Array<HeapType>) {
		match (code) {
			BpDefTypeCode.Function.code => return readDefFuncType(supertypes);
			BpDefTypeCode.Struct.code => if (extensions.GC) return readDefStructType(supertypes);
			BpDefTypeCode.Array.code => if (extensions.GC) return readDefArrayType(supertypes);
			BpDefTypeCode.SUB.code => if (subok) return readDefSubType();
		}
		err.rel(decoder, pt).InvalidTypeDeclCode(code);
	}
	def readDefSubType() {
		var count = readU32("supertype count", limits.max_supertypes);
		var supertypes = Array<HeapType>.new(int.view(count));
		for (i < count) {
			var pt = decoder.pos;
			var index = readU32("type index", u32.view(module.heaptypes.length));
			supertypes[i] = toHeapType(pt, int.!(index));
		}
		readDefType2(false, supertypes);
	}
	def readDefFuncType(supertypes: Array<HeapType>) {
		var ptypes = readValueTypes("param count", limits.max_num_func_params);
		if (!err.ok()) return;
		var rtypes = readValueTypes("result count", limits.max_num_func_results);
		if (!err.ok()) return;
		var decl = SigDecl.new(supertypes, ptypes, rtypes);
		module.addDecl(decl);
		decl.recgrp_index = decl.heaptype_index - max_fw_index;
	}
	def readDefStructType(supertypes: Array<HeapType>) {
		var count = readU32("field count", limits.max_num_struct_fields);
		if (!err.ok()) return;
		var field_types = Array<StorageType>.new(int.!(count));
		for (j < field_types.length) {
			field_types[j] = readStorageType();
		}
		if (!err.ok()) return;
		var decl = StructDecl.new(supertypes, field_types);
		module.addDecl(decl);
		decl.recgrp_index = decl.heaptype_index - max_fw_index;
	}
	def readDefArrayType(supertypes: Array<HeapType>) {
		var elem_type = readStorageType();
		if (!err.ok()) return;
		var decl = ArrayDecl.new(supertypes, [elem_type]);
		module.addDecl(decl);
		decl.recgrp_index = decl.heaptype_index - max_fw_index;
	}
	def readStorageType() -> StorageType {
		var pt = decoder.pos;
		var code = readTypeCode();
		var vt: ValueType, packed: Packedness;
		match (code) {
			BpTypeCode.I8.val => { vt = ValueType.I32; packed = Packedness.PACKED_I8; }
			BpTypeCode.I16.val => { vt = ValueType.I32; packed = Packedness.PACKED_I16; }
			_ => vt = readValueTypeSuffix(pt, code);
		}
		var mut = readMutability();
		return StorageType(vt, packed, mut);
	}
	def readValueTypes(quantity: string, limit: u32) -> Array<ValueType> {
		var count = readU32(quantity, limit);
		if (!err.ok()) return ValueTypes.NONE;
		var types = Array<ValueType>.new(int.!(count));
		for (j < types.length) {
			types[j] = readValueType();
		}
		return types;
	}
	def readImportDecl(index: int) {
		var module_name = readUtf8String("import module name");
		var field_name = readUtf8String("import field name");
		var pt = decoder.pos;
		var kind = readByte("import kind", BpConstants.renderImportKind);
		var decl: Decl;
		var args = Modules.NO_IMPORT_ARGS;
		if (extensions.TYPE_IMPORTS && kind == BpImportExportKind.Args.code) {
			var count = readU32("import arg count", limits.max_num_exports);
			if (!err.ok()) return;
			args = Array<Decl>.new(int.!(count));
			for (i < count) args[i] = readExportWithoutName();
			kind = readByte("import kind", BpConstants.renderImportKind);
		}
		match (kind) {
			BpImportExportKind.Function.code => {
				reserveOne(pt, "functions", module.functions, limits.max_num_functions);
				var sig_index = readSigIndex();
				decl = FuncDecl.new(sig_index);
			}
			BpImportExportKind.Table.code => {
				reserveOne(pt, "tables", module.tables, limits.max_num_tables);
				var et = readElemType();
				var l = readTableLimits();
				decl = TableDecl.new(et, l.0, l.1);
			}
			BpImportExportKind.Memory.code => {
				reserveOne(pt, "memories", module.memories, limits.max_num_memories);
				var l = readMemoryLimits();
				decl = MemoryDecl.new(l.0, l.1, l.2);
			}
			BpImportExportKind.Global.code => {
				reserveOne(pt, "globals", module.globals, limits.max_num_globals);
				var t = readValueType();
				var mut = readMutability();
				decl = GlobalDecl.new(t, mut, InitExpr.I32(0));
			}
			BpImportExportKind.AbsType.code => if (extensions.TYPE_IMPORTS) {
				var flags = readByte("flags", BpConstants.renderAbsTypeFlags);
				var has_default = (flags & BpAbsTypeFlag.HasDefault.mask) != 0;
				var is_externref = (flags & BpAbsTypeFlag.IsExternRef.mask) != 0;
				var count = readU32("constraint count", limits.max_num_type_constraints);
				var vec = Vector<ValueType>.new();
				if (count < limits.max_grow_size) vec.grow(int.!(count));
				for (i < count) {
					var b = readByte("constraint type", BpConstants.renderNone);
					if (b != 0) err.rel(decoder, pt).InvalidTypeConstraint(b);
					var t = readValueType();
					vec.put(t);
				}
				decl = AbsTypeDecl.new(has_default, is_externref, vec.extract());
			}
			BpImportExportKind.Command.code => if (extensions.TYPE_IMPORTS) {
				decl = ImportCommandDecl.new();
			}
		}
		if (decl == null) err.rel(decoder, pt).InvalidImportKind(kind);
		else module.addImport(module_name, field_name, args, decl);
	}
	def readFuncDecl(index: int) {
		var pt = decoder.pos;
		var sig_index = readSigIndex();
		var decl = FuncDecl.new(sig_index);
		module.addDecl(decl);
	}
	def readTableDecl(index: int) {
		var pt = decoder.pos;
		var et = readElemType();
		var l = readTableLimits();
		var decl = TableDecl.new(et, l.0, l.1);
		if (!ValueTypes.hasDefaultValue(et)) {
			err.rel(decoder, pt).ExpectedTypeWithDefaultValue(et);
		}
		module.addDecl(decl);
	}
	def readMemoryDecl(index: int) {
		var l = readMemoryLimits();
		var decl = MemoryDecl.new(l.0, l.1, l.2);
		module.addDecl(decl);
	}
	def readGlobalDecl(index: int) {
		var vt = readValueType();
		var mut = readMutability();
		var pos = decoder.pos;
		var expr = readInitExpr("global initializer", vt);
		var decl = GlobalDecl.new(vt, mut, expr);
		module.addDecl(decl);
	}
	def readMutability() -> bool {
		var pt = decoder.pos;
		var flags = readByte("mutability", BpConstants.renderMutability);
		if ((flags & 0xFE) != 0) {
			err.rel(decoder, pt).InvalidGlobalFlags(flags);
		}
		return (flags & BpGlobalFlag.Mutable.mask) != 0;
	}
	def readExportDecl(index: int, exportSet: StringSet) {
		var pt = decoder.pos;
		var name = readUtf8String("export name");
		if (exportSet != null && exportSet.add(name)) {
			err.rel(decoder, pt).DuplicateExport(index);
		}
		var decl = readExportWithoutName();
		module.exports.put(name, decl);
	}
	def readExportWithoutName() -> Decl {
		var pt = decoder.pos;
		var kind = readByte("export kind", BpConstants.renderImportKind);
		var decl: Decl;
		match (kind) {
			BpImportExportKind.Function.code => decl = readFuncRef();
			BpImportExportKind.Table.code => decl = readTableRef();
			BpImportExportKind.Memory.code => decl = readMemoryRef();
			BpImportExportKind.Global.code => decl = readGlobalRef();
			BpImportExportKind.AbsType.code => decl = readAbsTypeRef();
			_ => err.rel(decoder, pt).InvalidExportKind(kind);
		}
		return decl;
	}
	def readElemDecl(index: int) {
		var pt = decoder.pos;
		var flags = readByte("elem flags", BpConstants.renderNone);
		var vt: ValueType = ValueTypes.FUNCREF, mode: SegmentMode, details: ElemDetails;
		match (flags) {
			0 => {
				var table_index = checkIndex(pt, "table", 0, module.tables.length).1;
				var offset = readI32Expr("elements offset");
				mode = SegmentMode.Active(table_index, offset);
				details = readElemFuncIndexes(table_index);
			}
			1 => {
				mode = SegmentMode.Passive;
				readElemKind();
				details = readElemFuncIndexes(int.max);
			}
			2 => {
				var table_index = readTableIndex();
				var offset = readI32Expr("elements offset");
				readElemKind();
				mode = SegmentMode.Active(table_index, offset);
				details = readElemFuncIndexes(table_index);
			}
			3 => {
				mode = SegmentMode.Declarative;
				readElemKind();
				details = readElemFuncIndexes(int.max);
			}
			4 => {
				var table_index = checkIndex(pt, "table", 0, module.tables.length).1;
				var offset = readI32Expr("elements offset");
				mode = SegmentMode.Active(table_index, offset);
				details = readElemInitExprs(ValueTypes.FUNCREF);
			}
			5 => {
				mode = SegmentMode.Passive;
				vt = readRefType(false);
				details = readElemInitExprs(vt);
			}
			6 => {
				var table_index = readTableIndex();
				var offset = readI32Expr("elements offset");
				mode = SegmentMode.Active(table_index, offset);
				vt = readRefType(false);
				details = readElemInitExprs(vt);
			}
			7 => {
				mode = SegmentMode.Declarative;
				vt = readRefType(false);
				details = readElemInitExprs(vt);
			}
			_ => {
				err.rel(decoder, pt).InvalidElemFlags(flags);
			}
		}
		var d = ElemDecl.new(vt, mode, details);
		module.elems.put(d);
	}
	def readElemKind() {
		var pt = decoder.pos;
		var elem_kind = readByte("elem kind", BpConstants.renderNone);
		if (elem_kind != 0) err.rel(decoder, pt).ExpectedElemKindZeroByte(elem_kind);
	}
	def readElemFuncIndexes(table_index: int) -> ElemDetails.FuncRefs {
		var count = readU32("element count", limits.max_num_table_entries);
		var elemType: ValueType, expected_sig: SigDecl;
		if (table_index < module.tables.length) {
			elemType = module.tables[table_index].elemtype;
			match (elemType) {
				Ref(nullable, heap) => match (heap) {
					Func(sig) => expected_sig = sig;
					_ => err.at(decoder).TypeMismatchInElemInit(elemType, ValueTypes.FUNCREF);
				}
				_ => err.at(decoder).TypeMismatchInElemInit(elemType, ValueTypes.FUNCREF);
			}
		}
		var array = Array<int>.new(int.!(count));
		for (i < array.length) {
			var pt = decoder.pos;
			var f = readFuncRef();
			if (f != null) {
				f.reffed = true;
				array[i] = f.func_index;
				if (expected_sig != null && !f.sig.isAssignableSig(expected_sig)) {
					err.rel(decoder, pt).TypeMismatchInElemInit(elemType, ValueTypes.RefFunc(false, f.sig));
				}
			}
		}
		return ElemDetails.FuncRefs(array);
	}
	def readElemInitExprs(elemType: ValueType) -> ElemDetails.Exprs {
		var count = readU32("element count", limits.max_num_table_entries);
		var array = Array<InitExpr>.new(int.!(count));
		for (i < array.length) {
			var pt = decoder.pos;
			var expr = readInitExpr("element", elemType);
			array[i] = expr;
		}
		return ElemDetails.Exprs(array);
	}
	def readDataDecl(index: int) {
		var pt = decoder.pos;
		var flags = readByte("data flags", BpConstants.renderNone);
		var mode: SegmentMode;
		match (flags) {
			0 => {
				var mem_index = checkIndex(pt, "memory", 0, module.memories.length).1;
				var offset = readI32Expr("data element offset");
				mode = SegmentMode.Active(mem_index, offset);
			}
			1 => {
				mode = SegmentMode.Passive;
			}
			2 => {
				var mem_index = readMemoryIndex();
				var offset = readI32Expr("data element offset");
				mode = SegmentMode.Active(mem_index, offset);
			}
			_ => {
				err.rel(decoder, pt).InvalidDataFlags(flags);
			}
		}
		var len = readU32("data segment size", limits.max_data_segment_size);
		var data = decoder.readN(int.!(len));
		var d = DataDecl.new(mode, data);
		module.data.put(d);
	}
	def traceBytes(pt: int, quantity: string) {
		if (quantity == null) return;
		var count = decoder.pos - pt;
		OUT.put1("%x: ", decoder.abs_of(pt));
		for (i < count) {
			if (i > 0 && (i % 8) == 0) OUT.puts("\n          ");
			OUT.put1("%x ", decoder.data[pt + i]);
		}
		var rounded = ((count + 7) / 8) * 8;
		for (i < rounded - count) OUT.puts("   ");
		OUT.put1(" %s = ", quantity);
	}

	def debugBuffer() {
		if (!Trace.binparse) return;
		OUT.put2("[buf@+%d limit=%d ", decoder.pos, decoder.limit);
		if (eof) OUT.puts("eof ");
		if (err.error_pos < int.max) {
			OUT.put1("err@+%d ", err.error_pos);
		}
		if (err.error_msg != null) {
			OUT.put1("msg=\"%s\"", err.error_msg);
		}
		OUT.putc(']').outln();
	}

	def toPrintableChar(b: byte) -> byte {
		if (b < ' ' || b > 127) b = '.';
		return b;
	}
	def readCountAndReserve<T>(quantity: string, vec: Vector<T>, max: u32) -> u32 {
		var pt = decoder.pos;
		var count = readU32(quantity, max);
		var total = (u32.view(vec.length) + count);
		if (total > max) {
			err.rel(decoder, pt).TotalExceededMaximum(quantity, total, max);
		} else {
			vec.grow(int.view(total));
		}
		return count;
	}
	def reserveOne<T>(pt: int, quantity: string, vec: Vector<T>, max: u32) {
		var total = u32.view(vec.length) + 1u;
		if (total > max) {
			err.rel(decoder, pt).TotalExceededMaximum(quantity, total, max);
		}
	}
}

// A finite state machine that implements a push-based parser for binary
// modules. This class handles the decoding of complete sections and complete
// function bodies, invoking callbacks when sections, bodies, and the overall
// module is finished.
class BpFsm extends WasmParser {
	def callback: BpFsmCallback;
	var section_decoder: DataReader;
	var function_decoder: DataReader;

	// Internal state
	var state: BpFsmState;
	var current_pos: int;
	var more = true;
	var accept = false;
	var current_section: BpSection;
	var section_start: int;
	var section_size: u32;
	var function_body_count: u32;
	var current_function_body: u32;
	var function_body_start: int;
	var function_body_size: u32;

	new(extensions: Extension.set, limits: Limits, err: ErrorGen, callback: BpFsmCallback)
			super(extensions, limits, callback.module,
				err,
				Decoder.new(null, err)) {
		decoder.onEOF = eof_set_flag;
		section_decoder = Decoder.new(null, err);
		section_decoder.onEOF = eof_is_section_overflow;
		function_decoder = Decoder.new(null, err);
		function_decoder.onEOF = eof_is_function_overflow;
	}

	def push(x: Array<byte>, xpos: int, xlength: int) {
		eof = false;
		decoder.putk(0, x, xpos, xlength);
		decodeLoop();
	}
	def finish() -> BinParserResult {
		eof = false;
		more = false;
		decodeLoop();
		if (accept && err.ok()) return BinParserResult.Ok(callback.module);
		return BinParserResult.Error(err.error_code, callback.module.filename,
				err.error_section, err.error_index,
				err.error_pos, err.error_msg);
	}

	private def decodeLoop() {
		while (true) {
			advance();
			if (eof) return;
			if (accept) return;
			if (err.error()) return;
		}
	}
	private def advance() {
		current_pos = decoder.pos;
		if (Trace.binparse) {
// TODO: this is debug code, not tracing code
//			OUT.put3("@+%d [%d bytes] BpFsm.state=%s", decoder.abspos(),
//				decoder.available(), state.name).outln();
		}
		match (state) {
			MAGIC => {
				var pt = decoder.pos;
				var magic = decoder.read_u32();
				if (eof) return if(!retry(), err.at(decoder).EOFMagicWord());
				if (magic != BpConstants.WASM_MAGIC) err.rel(decoder, pt).InvalidMagicWord(magic);
				state = BpFsmState.VERSION;
			}
			VERSION => {
				var pt = decoder.pos;
				var version = decoder.read_u32();
				if (eof) return if(!retry(), err.at(decoder).EOFWasmVersion());
				if (version != BpConstants.WASM_VERSION) err.rel(decoder, pt).InvalidWasmVersion(version);
				state = BpFsmState.SECTION_START;
			}
			SECTION_START => {
				var b = readByte("section code", BpConstants.renderSectionName);
				if (eof) {
					if (!retry()) accept = true;
					return;
				}
				current_section = checkSectionCode(b);
				state = BpFsmState.SECTION;
			}
			SECTION => {
				var pt = decoder.pos;
				section_size = readU32("section size", limits.max_module_size);
				if (eof) return if(!retry(), err_incomplete_section(decoder.abs_of(pt), 0));
				section_start = decoder.abspos();
				state = BpFsmState.SECTION_WITH_SIZE;
			}
			SECTION_WITH_SIZE => {
				match (current_section) {
					Code => {  // code section handled specially, one function body at a time
						function_body_count = readU32("function body count", limits.max_num_functions);
						if (eof) return if(!retry(), err_incomplete_section(section_start, section_size));
						function_body_start = decoder.abspos();
						current_function_body = 0;
						state = BpFsmState.BODY;
						callback.beginCodeSection(function_body_start, function_body_count);
					}
					_ => {
						decoder.sub_bytes(section_decoder, int.!(section_size));
						if (eof) return if(!retry(), err_incomplete_section(section_start, section_size));
						callback.decodeSection(current_section, section_size, section_decoder);
						state = BpFsmState.SECTION_START;
					}
				}
			}
			BODY => {
				if (current_function_body == function_body_count) { // already read N bodies
					var read = decoder.abspos() - section_start;
					if (read < section_size) err.at(decoder).IncompleteSection(BpSection.Code.code, read, section_size);
					if (read > section_size) err.at(decoder).OverflowSection(BpSection.Code.code, read, section_size);
					state = BpFsmState.SECTION_START;
				} else {
					function_body_size = readU32("function body size", limits.max_func_size);
					if (eof) return if(!retry(), err_incomplete_function(current_function_body, 0));
					state = BpFsmState.BODY_WITH_SIZE;
				}
			}
			BODY_WITH_SIZE => {
				decoder.sub_bytes(function_decoder, int.!(function_body_size));
				var next_start = decoder.abspos();
				if (eof) return if(!retry(), err_incomplete_function(current_function_body, function_body_size));
				callback.decodeFunctionBody(current_function_body, function_body_size, function_decoder);
				function_body_start = next_start;
				current_function_body++;
				state = BpFsmState.BODY;
			}
		}
	}
	def retry() -> bool {
		if (more) {
			decoder.at(current_pos);
			return true;
		}
		return false;
	}
	def checkSectionCode(b: byte) -> BpSection {
		if (!BpConstants.valid_section[b]) {
			err.at(decoder).InvalidSectionCode(b);
		}
		return BpConstants.enum_section[b];
	}
	def eof_is_section_overflow(d: DataReader, pos: int, size: int, msg: string) {
		var kind = current_section.code;
		var read = d.abs_of(pos) - section_start;
		var size = section_size;
		err.rel(d, pos).OverflowSection(kind, read, size);
	}
	def eof_is_function_overflow(d: DataReader, pos: int, size: int, msg: string) {
		var read = d.abs_of(pos) - function_body_start;
		var size = function_body_size;
		err.rel(d, pos).OverflowFunctionBody(read, size);
	}
	def err_incomplete_section(abs: int, size: u32) {
		var kind = current_section;
		var read = decoder.abspos() - abs;
		err.at(decoder).IncompleteSection(kind.code, read, size);
	}
	def err_incomplete_function(index: u32, size: u32) {
		var read = decoder.abspos() - function_body_start;
		err.at(decoder).IncompleteFunctionBody(read, size);
	}
}
// The callbacks for sections, function bodies, and finishing a module.
class BpFsmCallback(module: Module) {
	def decodeSection(kind: BpSection, size: u32, d: DataReader);
	def beginCodeSection(abspos: int, count: u32) {}
	def decodeFunctionBody(index: u32, size: u32, d: DataReader);
}
// The states for the module parser finite state machine.
enum BpFsmState {
	MAGIC,
	VERSION,
	SECTION_START,
	SECTION,
	SECTION_WITH_SIZE,
	BODY,
	BODY_WITH_SIZE
}
