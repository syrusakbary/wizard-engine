// Copyright 2020 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// Executes wasm code using portable Virgil III code and datastructures.
def OUT = Trace.OUT;
def E: Execute;
component V3Interpreter {
	var instrTracer: InstrTracer;
	def val_stack = ArrayStack<Value>.new();   // XXX: inline value stack array and top
	def codeptr = CodePtr.new(null);	// pointer into code
	private var frame: Frame;		// cached of top-of-stack frame, TODO: V3Interpreter
	private def call_stack = ArrayStack<Frame>.new();
	private var entry: Function;		// entrypoint function from {run()}

	def run(f: Function, args: Array<Value>) -> Result {
		// Reset interpreter state
		reset();
		// Push arguments onto the stack
		val_stack.resize(0);
		if (args != null) for (a in args) val_stack.push(a);
		// Push synthetic top frame onto the stack
		entry = f;
		var synth = FuncDecl.new(f.sig.heaptype_index);
		synth.sig = f.sig;
		synth.code = SYNTH_CODE;
		pushFrame(WasmFunction.new(null, synth));
		// Begin execution
		E.state = if(E.probes == null, ExecState.RUN_FAST, ExecState.RUN_SLOW);
		loop();
		// Convert internal state into result
		match (E.state) {
			FINISHED => return Result.Value(popN(f.sig.results.length));
			TRAPPED => return Result.Trap(E.trap_reason);
			_ => System.error("InterpreterError", "unexpected state");
		}
		return Result.Break;
	}
	def reset() {
		frame = null;
		val_stack.top = 0;
		call_stack.top = 0;
	}
	def getTopFrame() -> Frame {
		return frame;
	}
	def getCallStack() -> ArrayStack<Frame> {
		return call_stack;
	}
	def getCallDepth() -> int {
		return call_stack.top;
	}
	def pushFrame(f: WasmFunction) {
		if (call_stack.top >= E.limits.max_call_depth) {
			return trap(TrapReason.STACK_OVERFLOW);
		}
		if (Trace.interpreter) traceFrame(f);
		// Allocate a frame
		var nf = call_stack.next();
		if (nf != null) {  // reuse cached Frame object if possible
			call_stack.top++;
		} else {
			nf = Frame.new();
			call_stack.push(nf);
		}
		var sp = val_stack.top;
		nf.fp = sp - f.decl.sig.params.length;
		// Setup function and code pointer
		nf.func = f;
		nf.pc = 0;
		nf.xip = 0;
		var code = f.decl.code.code;
		codeptr.reset(code, 0, code.length);
		// Initialize locals
		val_stack.resize(sp + f.decl.code.num_locals);
		var count = codeptr.read_uleb32();
		for (i < count) {
			var num = codeptr.read_uleb32();
			var t = codeptr.read1();
			var val: Value;
			match (t) {
				BpTypeCode.I32.code => val = Values.I32_0;
				BpTypeCode.I64.code => val = Values.I64_0;
				BpTypeCode.F32.code => val = Values.F32_0;
				BpTypeCode.F64.code => val = Values.F64_0;
				BpTypeCode.FUNCREF.code => val = Values.FUNCREF_NULL;
				BpTypeCode.ANYREF.code,
				BpTypeCode.I31REF.code,
				BpTypeCode.EXTERNREF.code => val = Values.REF_NULL;
				BpTypeCode.REF_NULL.code => {
					codeptr.read_uleb32(); // skip sig decl index
					val = Values.FUNCREF_NULL;
				}
				BpTypeCode.ABS.code => {
					var abstype_index = codeptr.read_uleb32();
					val = f.instance.defvals[abstype_index];
				}
				_ => error("invalid local value type");
			}
			for (i < num) val_stack.elems[sp++] = val;
		}
		nf.pc = codeptr.pos; // move code pointer after locals
		frame = nf;
	}
	def traceFrame(f: WasmFunction) {
		for (i < call_stack.top) OUT.sp();
		OUT.put2("pushFrame(func %q: %q)", f.renderShort, f.decl.sig.render).outln();
	}
	def loop() {
		while (true) {
			while (E.state == ExecState.RUN_FAST) {
				if (Trace.interpreter) traceStep(); // TODO: make into a probe
				var pc = codeptr.pos;
				var opcode = codeptr.read1();
				var origop = execOp(pc, opcode);
				if (origop == 0) continue;  // instruction executed successfully
				if (origop < 0) break;  // breakpoint
				execOp(pc, byte.view(origop)); // breakpoint resumed, execute original code
			}
			while (E.state == ExecState.RUN_SLOW) {
				var pc = codeptr.pos;
				frame.pc = pc;
				E.fireProbes(frame.func, pc);
				var opcode = codeptr.read1();
				var origop = execOp(pc, opcode);
				if (origop == 0) continue;  // instruction executed successfully
				if (origop < 0) break;  // breakpoint
				execOp(pc, byte.view(origop)); // breakpoint resumed, execute original code
			}
			if (E.state != ExecState.RUN_FAST) break;
		}
	}
	// Execute the given opcode and return {0} if successfully executed. If a breakpoint
	// is hit and the state is {RUNNING}, then {-1} is returned. If the state is {RESUME},
	// then, the original opcode is returned, encoded into the (nonzero) return value.
	def execOp(pc: int, opcode: byte) -> int {
		match (opcode) {
			Opcode.UNREACHABLE.code => {
				trap(TrapReason.UNREACHABLE);
			}
			Opcode.NOP.code => {
				// do nothing
			}
			Opcode.BLOCK.code,
			Opcode.LOOP.code => {
				codeptr.skip_block_type();
			}
			Opcode.IF.code => {
				var cond = popi();
				if (cond == 0) {
					codeptr.at(doGoto(pc));
				} else {
					codeptr.skip_block_type();
					doFallthru();
				}
			}
			Opcode.ELSE.code => {
				codeptr.at(doGoto(pc));
			}
			Opcode.END.code => {
				if (codeptr.available() == 0) doReturn();
			}
			Opcode.BR.code => {
				codeptr.at(doGoto(pc));
			}
			Opcode.BR_IF.code => {
				var cond = popi();
				doBranch(pc, cond != 0);
			}
			Opcode.BR_TABLE.code => {
				var key = popu();
				codeptr.at(doSwitch(pc, key));
			}
			Opcode.RETURN.code => {
				doReturn();
			}
			Opcode.CALL.code => {
				var func_index = codeptr.read_uleb32();
				var f = frame.func.instance.functions[func_index];
				doCallFunction(f);
			}
			Opcode.CALL_INDIRECT.code => {
				var sig_index = codeptr.read_uleb32();
				var table_index = codeptr.read_uleb32();
				var func_index = popu();
				var f = lookupIndirect(sig_index, table_index, func_index);
				if (f != null) doCallFunction(f);
			}
			Opcode.RETURN_CALL.code => {
				var func_index = codeptr.read_uleb32();
				var f = frame.func.instance.functions[func_index];
				prepareReturnCall(f.sig);
				doCallFunction(f);
			}
			Opcode.RETURN_CALL_INDIRECT.code => {
				var sig_index = codeptr.read_uleb32();
				var table_index = codeptr.read_uleb32();
				var func_index = popu();
				var f = lookupIndirect(sig_index, table_index, func_index);
				if (f != null) {
					prepareReturnCall(f.sig);
					doCallFunction(f);
				}
			}
			Opcode.CALL_REF.code => {
				var v = pop();
				var func = Function.!(Value.Ref.!(v).val);
				if (func == null) trap(TrapReason.NULL_DEREF);
				else doCallFunction(func);
			}
			Opcode.RETURN_CALL_REF.code => {
				var v = pop();
				var func = Function.!(Value.Ref.!(v).val);
				if (func == null) {
					trap(TrapReason.NULL_DEREF);
				} else {
					prepareReturnCall(func.sig);
					doCallFunction(func);
				}
			}
			Opcode.FUNC_BIND.code => {
				var index = codeptr.read_uleb32();
				var sig = frame.func.instance.sigs[index];
				var v = pop();
				var func = Function.!(Value.Ref.!(v).val);
				if (func == null) {
					trap(TrapReason.NULL_DEREF);
				} else {
					var diff = func.sig.params.length - sig.params.length;
					var nsig = func.sig.bindLeft(diff);
					var args = popN(diff);
					var bf = HostFunctionN.new(null, nsig, Execute.fwBoundCall(func, args, _));
					push(Value.Ref(bf));
				}
			}
			Opcode.DROP.code => {
				pop();
			}
			Opcode.SELECT.code => {
				var cond = popu(), b = pop(), a = pop();
				push(if(cond != 0, a, b));
			}
			Opcode.SELECT_T.code => {
				var count = codeptr.read_value_types();
				var cond = popu();
				if (cond != 0) {
					val_stack.top -= count; // pop false values off the stack
				} else {
					copyVals(count, val_stack.top - (count << 1)); // transfer false values down
				}
			}
			Opcode.LOCAL_GET.code => {
				var index = codeptr.read_uleb32();
				push(val_stack.elems[frame.fp + int.!(index)]);
			}
			Opcode.LOCAL_SET.code => {
				var index = codeptr.read_uleb32();
				val_stack.elems[frame.fp + int.!(index)] = pop();
			}
			Opcode.LOCAL_TEE.code => {
				var index = codeptr.read_uleb32();
				val_stack.elems[frame.fp + int.!(index)] = val_stack.peek();
			}
			Opcode.GLOBAL_GET.code => {
				var index = codeptr.read_uleb32();
				push(frame.func.instance.globals[index].value);
			}
			Opcode.GLOBAL_SET.code => {
				var index = codeptr.read_uleb32();
				frame.func.instance.globals[index].value = pop();
			}
			Opcode.TABLE_GET.code => {
				var index = codeptr.read_uleb32();
				var elems = frame.func.instance.tables[index].elems;
				var elem = popu();
				if (elem >= elems.length) {
					trap(TrapReason.TABLE_OUT_OF_BOUNDS);
				} else {
					push(elems[elem]);
				}
			}
			Opcode.TABLE_SET.code => {
				var index = codeptr.read_uleb32();
				var table = frame.func.instance.tables[index];
				var val = pop();
				var elem = popu();
				if (elem >= table.elems.length) {
					trap(TrapReason.TABLE_OUT_OF_BOUNDS);
				} else {
					table[int.!(elem)] = val;
				}
			}

			Opcode.I32_LOAD.code => doLoad(do_i32_load);
			Opcode.I64_LOAD.code => doLoad(do_i64_load);
			Opcode.F32_LOAD.code => doLoad(do_f32_load);
			Opcode.F64_LOAD.code => doLoad(do_f64_load);
			Opcode.I32_LOAD8_S.code => doLoad(do_i32_load8_s);
			Opcode.I32_LOAD8_U.code => doLoad(do_i32_load8_u);
			Opcode.I32_LOAD16_S.code => doLoad(do_i32_load16_s);
			Opcode.I32_LOAD16_U.code => doLoad(do_i32_load16_u);
			Opcode.I64_LOAD8_S.code => doLoad(do_i64_load8_s);
			Opcode.I64_LOAD8_U.code => doLoad(do_i64_load8_u);
			Opcode.I64_LOAD16_S.code => doLoad(do_i64_load16_s);
			Opcode.I64_LOAD16_U.code => doLoad(do_i64_load16_u);
			Opcode.I64_LOAD32_S.code => doLoad(do_i64_load32_s);
			Opcode.I64_LOAD32_U.code => doLoad(do_i64_load32_u);
			Opcode.I32_STORE.code => doStore(do_i32_store);
			Opcode.I64_STORE.code => doStore(do_i64_store);
			Opcode.F32_STORE.code => doStore(do_f32_store);
			Opcode.F64_STORE.code => doStore(do_f64_store);
			Opcode.I32_STORE8.code => doStore(do_i32_store8);
			Opcode.I32_STORE16.code => doStore(do_i32_store16);
			Opcode.I64_STORE8.code => doStore(do_i64_store8);
			Opcode.I64_STORE16.code => doStore(do_i64_store16);
			Opcode.I64_STORE32.code => doStore(do_i64_store32);

			Opcode.MEMORY_SIZE.code => {
				var index = codeptr.read_uleb32();
				var pages = frame.func.instance.memories[index].size();
				pushu(pages);
			}
			Opcode.MEMORY_GROW.code => {
				var index = codeptr.read_uleb32();
				var result = frame.func.instance.memories[index].grow(popu());
				pushu(u32.view(result));
			}

			Opcode.I32_CONST.code => pushi(codeptr.read_sleb32());
			Opcode.I64_CONST.code => pushl(codeptr.read_sleb64());
			Opcode.F32_CONST.code => push(Value.F32(codeptr.read_u32()));
			Opcode.F64_CONST.code => push(Value.F64(codeptr.read_u64()));

			Opcode.I32_EQZ.code => pushz(popu() == 0);
			Opcode.I32_EQ.code => do_uu_z(u32.==);
			Opcode.I32_NE.code => do_uu_z(u32.!=);
			Opcode.I32_LT_S.code => do_ii_z(i32.<);
			Opcode.I32_LT_U.code => do_uu_z(u32.<);
			Opcode.I32_GT_S.code => do_ii_z(i32.>);
			Opcode.I32_GT_U.code => do_uu_z(u32.>);
			Opcode.I32_LE_S.code => do_ii_z(i32.<=);
			Opcode.I32_LE_U.code => do_uu_z(u32.<=);
			Opcode.I32_GE_S.code => do_ii_z(i32.>=);
			Opcode.I32_GE_U.code => do_uu_z(u32.>=);

			Opcode.I64_EQZ.code => pushz(popw() == 0);
			Opcode.I64_EQ.code => do_ww_z(u64.==);
			Opcode.I64_NE.code => do_ww_z(u64.!=);
			Opcode.I64_LT_S.code => do_ll_z(i64.<);
			Opcode.I64_LT_U.code => do_ww_z(u64.<);
			Opcode.I64_GT_S.code => do_ll_z(i64.>);
			Opcode.I64_GT_U.code => do_ww_z(u64.>);
			Opcode.I64_LE_S.code => do_ll_z(i64.<=);
			Opcode.I64_LE_U.code => do_ww_z(u64.<=);
			Opcode.I64_GE_S.code => do_ll_z(i64.>=);
			Opcode.I64_GE_U.code => do_ww_z(u64.>=);

			Opcode.F32_EQ.code => do_ff_z(float.==);
			Opcode.F32_NE.code => do_ff_z(float.!=);
			Opcode.F32_LT.code => do_ff_z(float.<);
			Opcode.F32_GT.code => do_ff_z(float.>);
			Opcode.F32_LE.code => do_ff_z(float.<=);
			Opcode.F32_GE.code => do_ff_z(float.>=);
			Opcode.F64_EQ.code => do_dd_z(double.==);
			Opcode.F64_NE.code => do_dd_z(double.!=);
			Opcode.F64_LT.code => do_dd_z(double.<);
			Opcode.F64_GT.code => do_dd_z(double.>);
			Opcode.F64_LE.code => do_dd_z(double.<=);
			Opcode.F64_GE.code => do_dd_z(double.>=);

			Opcode.I32_CLZ.code => do_u_u(Execute.I32_CLZ);
			Opcode.I32_CTZ.code => do_u_u(Execute.I32_CTZ);
			Opcode.I32_POPCNT.code => do_u_u(Execute.I32_POPCNT);
			Opcode.I32_ADD.code => do_uu_u(u32.+);
			Opcode.I32_SUB.code => do_uu_u(u32.-);
			Opcode.I32_MUL.code => do_uu_u(u32.*);
			Opcode.I32_DIV_S.code => {
				var y = popi(), x = popi();
				if (y == 0) trap(TrapReason.DIV_BY_ZERO);
				else if (y == -1 && x == int.min) trap(TrapReason.DIV_UNREPRESENTABLE);
				else pushi(x / y);
			}
			Opcode.I32_DIV_U.code => {
				var y = popu(), x = popu();
				if (y == 0) trap(TrapReason.DIV_BY_ZERO);
				else pushu(x / y);
			}
			Opcode.I32_REM_S.code => {
				var y = popi(), x = popi();
				if (y == 0) trap(TrapReason.DIV_BY_ZERO);
				else if (y == -1) pushi(0);
				else pushi(x % y);
			}
			Opcode.I32_REM_U.code => {
				var y = popu(), x = popu();
				if (y == 0) trap(TrapReason.DIV_BY_ZERO);
				else if (y == 1) pushi(0);
				else pushu(x % y);
			}
			Opcode.I32_AND.code => do_uu_u(u32.&);
			Opcode.I32_OR.code => do_uu_u(u32.|);
			Opcode.I32_XOR.code => do_uu_u(u32.^);
			Opcode.I32_SHL.code => do_ii_i(Execute.I32_SHL);
			Opcode.I32_SHR_S.code => do_ii_i(Execute.I32_SHR_S);
			Opcode.I32_SHR_U.code => do_ii_i(Execute.I32_SHR_U);
			Opcode.I32_ROTL.code => do_uu_u(Execute.I32_ROTL);
			Opcode.I32_ROTR.code => do_uu_u(Execute.I32_ROTR);

			Opcode.I64_CLZ.code => do_w_w(Execute.I64_CLZ);
			Opcode.I64_CTZ.code => do_w_w(Execute.I64_CTZ);
			Opcode.I64_POPCNT.code => do_w_w(Execute.I64_POPCNT);

			Opcode.I64_ADD.code => do_ww_w(u64.+);
			Opcode.I64_SUB.code => do_ww_w(u64.-);
			Opcode.I64_MUL.code => do_ww_w(u64.*);
			Opcode.I64_DIV_S.code => {
				var y = popl(), x = popl();
				if (y == 0) trap(TrapReason.DIV_BY_ZERO);
				else if (y == -1 && x == long.min) trap(TrapReason.DIV_UNREPRESENTABLE);
				else pushl(x / y);
			}
			Opcode.I64_DIV_U.code => {
				var y = popw(), x = popw();
				if (y == 0) trap(TrapReason.DIV_BY_ZERO);
				else pushw(x / y);
			}
			Opcode.I64_REM_S.code => {
				var y = popl(), x = popl();
				if (y == 0) trap(TrapReason.DIV_BY_ZERO);
				else if (y == -1) pushw(0);
				else pushl(x % y);
			}
			Opcode.I64_REM_U.code => {
				var y = popw(), x = popw();
				if (y == 0) trap(TrapReason.DIV_BY_ZERO);
				else if (y == 1) pushw(0);
				else pushw(x % y);
			}
			Opcode.I64_AND.code => do_ww_w(u64.&);
			Opcode.I64_OR.code => do_ww_w(u64.|);
			Opcode.I64_XOR.code => do_ww_w(u64.^);
			Opcode.I64_SHL.code => do_ww_w(Execute.I64_SHL);
			Opcode.I64_SHR_S.code => do_ll_l(Execute.I64_SHR_S);
			Opcode.I64_SHR_U.code => do_ww_w(Execute.I64_SHR_U);
			Opcode.I64_ROTL.code => do_ww_w(Execute.I64_ROTL);
			Opcode.I64_ROTR.code => do_ww_w(Execute.I64_ROTR);

			Opcode.F32_ABS.code => do_f_f(float.abs);
			Opcode.F32_NEG.code => do_f_f(Execute.fneg);
			Opcode.F32_CEIL.code => do_f_f(Execute.fceil);
			Opcode.F32_FLOOR.code => do_f_f(Execute.ffloor);
			Opcode.F32_TRUNC.code => do_f_f(Execute.ftrunc);
			Opcode.F32_NEAREST.code => do_f_f(float.round);
			Opcode.F32_SQRT.code => do_f_f(float.sqrt);
			Opcode.F32_ADD.code => do_ff_f(float.+);
			Opcode.F32_SUB.code => do_ff_f(float.-);
			Opcode.F32_MUL.code => do_ff_f(float.*);
			Opcode.F32_DIV.code => do_ff_f(float./);
			Opcode.F32_MIN.code => do_ff_f(Execute.fmin);
			Opcode.F32_MAX.code => do_ff_f(Execute.fmax);
			Opcode.F32_COPYSIGN.code => do_ff_f(Execute.fcopysign);

			Opcode.F64_ABS.code => do_d_d(double.abs);
			Opcode.F64_NEG.code => do_d_d(Execute.dneg);
			Opcode.F64_CEIL.code => do_d_d(Execute.dceil);
			Opcode.F64_FLOOR.code => do_d_d(Execute.dfloor);
			Opcode.F64_TRUNC.code => do_d_d(Execute.dtrunc);
			Opcode.F64_NEAREST.code => do_d_d(double.round);
			Opcode.F64_SQRT.code => do_d_d(double.sqrt);
			Opcode.F64_ADD.code => do_dd_d(double.+);
			Opcode.F64_SUB.code => do_dd_d(double.-);
			Opcode.F64_MUL.code => do_dd_d(double.*);
			Opcode.F64_DIV.code => do_dd_d(double./);
			Opcode.F64_MIN.code => do_dd_d(Execute.dmin);
			Opcode.F64_MAX.code => do_dd_d(Execute.dmax);
			Opcode.F64_COPYSIGN.code => do_dd_d(Execute.dcopysign);

			Opcode.I32_WRAP_I64.code => pushu(u32.view(popw()));

			Opcode.I32_TRUNC_F32_S.code => doTruncF32(-2.1474839E9f, 2147483648f, i32.truncf, pushi);
			Opcode.I32_TRUNC_F32_U.code => doTruncF32(-1f, 4294967296f, u32.truncf, pushu);
			Opcode.I32_TRUNC_F64_S.code => doTruncF64(-2147483649d, 2147483648f, i32.truncd, pushi);
			Opcode.I32_TRUNC_F64_U.code => doTruncF64(-1d, 4294967296d, u32.truncd, pushu);

			Opcode.I64_EXTEND_I32_S.code => pushw(u64.view(i64.!(popi())));
			Opcode.I64_EXTEND_I32_U.code => pushw(popu());

			Opcode.I64_TRUNC_F32_S.code => doTruncF32(-9.223373e18f, 9223372036854775808f, i64.truncf, pushl);
			Opcode.I64_TRUNC_F32_U.code => doTruncF32(-1f, 18446744073709551616f, u64.truncf, pushw);
			Opcode.I64_TRUNC_F64_S.code => doTruncF64(-9.223372036854778E18d, 9223372036854775808d, i64.truncd, pushl);
			Opcode.I64_TRUNC_F64_U.code => doTruncF64(-1d, 18446744073709551616d, u64.truncd, pushw);

			Opcode.F32_CONVERT_I32_S.code => pushf(float.roundi(popi()));
			Opcode.F32_CONVERT_I32_U.code => pushf(float.roundi(popu()));
			Opcode.F32_CONVERT_I64_S.code => pushf(float.roundi(popl()));
			Opcode.F32_CONVERT_I64_U.code => pushf(float.roundi(popw()));
			Opcode.F32_DEMOTE_F64.code => pushf(float.roundd(popd()));
			Opcode.F64_CONVERT_I32_S.code => pushd(double.roundi(popi()));
			Opcode.F64_CONVERT_I32_U.code => pushd(double.roundi(popu()));
			Opcode.F64_CONVERT_I64_S.code => pushd(double.roundi(popl()));
			Opcode.F64_CONVERT_I64_U.code => pushd(double.roundi(popw()));
			Opcode.F64_PROMOTE_F32.code => pushd(double.!(popf()));

			Opcode.I32_REINTERPRET_F32.code => pushu(Value.F32.!(pop()).bits);
			Opcode.F32_REINTERPRET_I32.code => push(Value.F32(popu()));
			Opcode.I64_REINTERPRET_F64.code => pushw(Value.F64.!(pop()).bits);
			Opcode.F64_REINTERPRET_I64.code => push(Value.F64(popw()));

			Opcode.I32_EXTEND8_S.code => pushi(i8.view(popi()));
			Opcode.I32_EXTEND16_S.code => pushi(i16.view(popi()));
			Opcode.I64_EXTEND8_S.code => pushl(i8.view(popl()));
			Opcode.I64_EXTEND16_S.code => pushl(i16.view(popl()));
			Opcode.I64_EXTEND32_S.code => pushl(i32.view(popl()));

			Opcode.REF_NULL.code => {
				var index = codeptr.read_sleb32();
				push(Values.REF_NULL);
			}
			Opcode.REF_IS_NULL.code => {
				var v = pop();
				var r = Values.isNull(v);
				pushz(r);
			}
			Opcode.REF_FUNC.code => {
				var index = codeptr.read_uleb32();
				var func = frame.func.instance.functions[index];
				push(Value.Ref(func));
			}
			Opcode.REF_AS_NON_NULL.code => {
				var v = pop();
				if (Values.isNull(v)) trap(TrapReason.NULL_DEREF);
				else push(v);
			}
			Opcode.BR_ON_NULL.code => {
				var v = pop();
				if (Values.isNull(v)) { // XXX: use doBranch
					codeptr.at(doGoto(pc));
				} else {
					codeptr.skip_label();
					push(v);
					doFallthru();
				}
			}
			Opcode.REF_EQ.code => {
				var a = pop();
				var b = pop();
				pushz(a == b);
			}
			Opcode.BR_ON_NON_NULL.code => {
				var v = pop();
				if (!Values.isNull(v)) {
					push(v);
					codeptr.at(doGoto(pc));
				} else {
					codeptr.skip_label();
					doFallthru();
				}
			}

			InternalOpcode.START.code => {
				doCallFunction(entry);
			}
			InternalOpcode.PROBE.code => {
				frame.pc = pc;
				if (Execute.fireProbesAt(frame.func, pc)) {
					var orig_opcode = frame.func.decl.code.orig[pc];
					return orig_opcode | 0x100;
				} else {
					codeptr.at(pc);
					return -1;
				}
			}

			0xFB => {
				var b2 = codeptr.read_uleb32();
				match (b2) {
					Opcode.STRUCT_NEW.code => {
						var index = codeptr.read_uleb32();
						var rtt = frame.func.instance.rtts[int.view(index)];
						var fields = popN(StructDecl.!(rtt.decl).field_types.length);
						push(Value.Ref(HeapStruct.new(rtt, fields)));
					}
					Opcode.STRUCT_NEW_WITH_RTT.code => {
						var index = codeptr.read_uleb32();
						var rtt = popRtt();
						var fields = popN(StructDecl.!(rtt.decl).field_types.length);
						push(Value.Ref(HeapStruct.new(rtt, fields)));
					}
					Opcode.STRUCT_NEW_DEFAULT_WITH_RTT.code => {
						var index = codeptr.read_uleb32();
						var rtt = popRtt();
						var fieldTypes = StructDecl.!(rtt.decl).field_types;
						var fields = Array<Value>.new(fieldTypes.length);
						for (i < fields.length) fields[i] = Values.default(fieldTypes[i].valtype);
						push(Value.Ref(HeapStruct.new(rtt, fields)));
					}
					Opcode.STRUCT_GET.code => {
						var index = codeptr.read_uleb32();
						var decl = StructDecl.!(frame.func.instance.heaptypes[int.view(index)]);
						var findex = codeptr.read_uleb32();
						var obj = HeapStruct.!(popr().val);
						if (obj == null) trap(TrapReason.NULL_DEREF);
						else push(obj.vals[findex]);
					}
					Opcode.STRUCT_GET_S.code => {
						var index = codeptr.read_uleb32();
						var decl = StructDecl.!(frame.func.instance.heaptypes[int.view(index)]);
						var findex = codeptr.read_uleb32();
						var obj = HeapStruct.!(popr().val);
						if (obj == null) trap(TrapReason.NULL_DEREF);
						else push(signExtend(decl.field_types[findex], obj.vals[findex]));
					}
					Opcode.STRUCT_GET_U.code => {
						var index = codeptr.read_uleb32();
						var decl = StructDecl.!(frame.func.instance.heaptypes[int.view(index)]);
						var findex = codeptr.read_uleb32();
						var obj = HeapStruct.!(popr().val);
						if (obj == null) trap(TrapReason.NULL_DEREF);
						else push(zeroExtend(decl.field_types[findex], obj.vals[findex]));
					}
					Opcode.STRUCT_SET.code => {
						var index = codeptr.read_uleb32();
						var decl = StructDecl.!(frame.func.instance.heaptypes[int.view(index)]);
						var findex = codeptr.read_uleb32();
						var val = pop();
						var obj = HeapStruct.!(popr().val);
						if (obj == null) trap(TrapReason.NULL_DEREF);
						else obj.vals[findex] = val; // TODO: narrow on store?
					}
					Opcode.ARRAY_NEW.code => {
						var index = codeptr.read_uleb32();
						var rtt = frame.func.instance.rtts[int.view(index)];
						var len = popu();
						var elem = pop();
						if (len > Execute.limits.max_array_length) {
							trap(TrapReason.OOM);
						} else {
							var length = int.view(len);
							var vals = Array<Value>.new(length);
							for (i < vals.length) vals[i] = elem;
							push(Value.Ref(HeapArray.new(rtt, vals)));
						}
					}
					Opcode.ARRAY_NEW_WITH_RTT.code => {
						var index = codeptr.read_uleb32();
						var rtt = popRtt();
						var len = popu();
						var elem = pop();
						if (len > Execute.limits.max_array_length) {
							trap(TrapReason.OOM);
						} else {
							var length = int.view(len);
							var vals = Array<Value>.new(length);
							for (i < vals.length) vals[i] = elem;
							push(Value.Ref(HeapArray.new(rtt, vals)));
						}
					}
					Opcode.ARRAY_NEW_DEFAULT_WITH_RTT.code => {
						var index = codeptr.read_uleb32();
						var rtt = popRtt();
						var len = popu();
						if (len > Execute.limits.max_array_length) {
							trap(TrapReason.OOM);
						} else {
							var length = int.view(len);
							var elem = Values.default(ArrayDecl.!(rtt.decl).elem_types[0].valtype);
							var vals = Array<Value>.new(length);
							for (i < vals.length) vals[i] = elem;
							push(Value.Ref(HeapArray.new(rtt, vals)));
						}
					}
					Opcode.ARRAY_GET.code => {
						var ignore = codeptr.read_uleb32();
						var index = popu();
						var obj = HeapArray.!(popr().val);
						if (obj == null) trap(TrapReason.NULL_DEREF);
						else if (index >= u32.view(obj.vals.length)) trap(TrapReason.ARRAY_INDEX_OOB);
						else push(obj.vals[index]);
					}
					Opcode.ARRAY_GET_S.code => {
						var index = codeptr.read_uleb32();
						var array = ArrayDecl.!(frame.func.instance.heaptypes[int.view(index)]);
						index = popu();
						var obj = HeapArray.!(popr().val);
						if (obj == null) trap(TrapReason.NULL_DEREF);
						else if (index >= u32.view(obj.vals.length)) trap(TrapReason.ARRAY_INDEX_OOB);
						else push(signExtend(array.elem_types[0], obj.vals[index]));
					}
					Opcode.ARRAY_GET_U.code => {
						var index = codeptr.read_uleb32();
						var array = ArrayDecl.!(frame.func.instance.heaptypes[int.view(index)]);
						index = popu();
						var obj = HeapArray.!(popr().val);
						if (obj == null) trap(TrapReason.NULL_DEREF);
						else if (index >= u32.view(obj.vals.length)) trap(TrapReason.ARRAY_INDEX_OOB);
						else push(zeroExtend(array.elem_types[0], obj.vals[index]));
					}
					Opcode.ARRAY_SET.code => {
						var ignore = codeptr.read_uleb32();
						var val = pop();
						var index = popu();
						var obj = HeapArray.!(popr().val);
						if (obj == null) trap(TrapReason.NULL_DEREF);
						else if (index >= u32.view(obj.vals.length)) trap(TrapReason.ARRAY_INDEX_OOB);
						else obj.vals[index] = val;
					}
					Opcode.ARRAY_LEN.code => {
						var ignore = codeptr.read_uleb32();
						var obj = HeapArray.!(popr().val);
						if (obj == null) trap(TrapReason.NULL_DEREF);
						else push(Value.I32(u32.view(obj.vals.length)));
					}
					Opcode.ARRAY_NEW_FIXED.code => {
						var index = codeptr.read_uleb32();
						var len = codeptr.read_u32();
						var rtt = popRtt();
						if (len > Execute.limits.max_array_length) {
							trap(TrapReason.OOM);
						} else {
							var length = int.view(len);
							var vals = Array<Value>.new(length);
							for (i = vals.length - 1; i >= 0; i--) vals[i] = pop();
							push(Value.Ref(HeapArray.new(rtt, vals)));
						}
					}
					Opcode.I31_NEW.code => {
						push(Value.I31(u31.view(popu())));
					}
					Opcode.I31_GET_S.code => {
						pushi(i31.view(Value.I31.!(pop()).val));
					}
					Opcode.I31_GET_U.code => {
						pushi(Value.I31.!(pop()).val);
					}
					Opcode.RTT_CANON.code => {
						var index = codeptr.read_uleb32();
						var decl = frame.func.instance.heaptypes[int.view(index)];
						push(Value.Ref(Canon.getRtt(decl)));
					}
					Opcode.REF_TEST.code => {
						var rtt = popRtt();
						var ref = popr();
						var ok = Execute.matchRtt(ref, rtt);
						pushz(ok);
					}
					Opcode.REF_CAST.code => {
						var rtt = popRtt();
						var ref = popr();
						var ok = Execute.matchRtt(ref, rtt);
						if (!ok) trap(TrapReason.FAILED_CAST);
						else push(ref);
					}
					Opcode.BR_ON_CAST.code => {
						var depth = codeptr.read_uleb32();
						var rtt = popRtt();
						var ref = popr();
						var ok = Execute.matchRtt(ref, rtt);
						push(ref);
						if (ok) codeptr.at(doGoto(pc));
						else doFallthru();
					}
					Opcode.BR_ON_CAST_FAIL.code => {
						var depth = codeptr.read_uleb32();
						var rtt = popRtt();
						var ref = popr();
						var ok = Execute.matchRtt(ref, rtt);
						push(ref);
						if (ok) doFallthru();
						else codeptr.at(doGoto(pc));
					}
					Opcode.REF_IS_FUNC.code => {
						pushz(Values.isFunc(pop()));
					}
					Opcode.REF_IS_DATA.code => {
						pushz(Values.isData(pop()));
					}
					Opcode.REF_IS_I31.code => {
						pushz(Values.isI31(pop()));
					}
					Opcode.REF_IS_ARRAY.code => {
						pushz(Values.isArray(pop()));
					}
					Opcode.REF_AS_FUNC.code => {
						var v = pop();
						if (Values.isFunc(v)) push(v);
						else trap(TrapReason.FAILED_CAST);
					}
					Opcode.REF_AS_DATA.code => {
						var v = pop();
						if (Values.isData(v)) push(v);
						else trap(TrapReason.FAILED_CAST);
					}
					Opcode.REF_AS_I31.code => {
						var v = pop();
						if (Values.isI31(v)) push(v);
						else trap(TrapReason.FAILED_CAST);
					}
					Opcode.REF_AS_ARRAY.code => {
						var v = pop();
						if (Values.isArray(v)) push(v);
						else trap(TrapReason.FAILED_CAST);
					}
					Opcode.BR_ON_FUNC.code => {
						doBranch(pc, Values.isFunc(val_stack.peek()));
					}
					Opcode.BR_ON_DATA.code => {
						doBranch(pc, Values.isData(val_stack.peek()));
					}
					Opcode.BR_ON_I31.code => {
						doBranch(pc, Values.isI31(val_stack.peek()));
					}
					Opcode.BR_ON_ARRAY.code => {
						doBranch(pc, Values.isArray(val_stack.peek()));
					}
					Opcode.BR_ON_NON_FUNC.code => {
						doBranch(pc, !Values.isFunc(val_stack.peek()));
					}
					Opcode.BR_ON_NON_DATA.code => {
						doBranch(pc, !Values.isData(val_stack.peek()));
					}
					Opcode.BR_ON_NON_I31.code => {
						doBranch(pc, !Values.isI31(val_stack.peek()));
					}
					Opcode.BR_ON_NON_ARRAY.code => {
						doBranch(pc, !Values.isArray(val_stack.peek()));
					}
					_ => unhandled2(opcode, b2);
				}
			}
			0xFC => {
				var b2 = codeptr.read_uleb32();
				match (b2) {
					Opcode.I32_TRUNC_SAT_F32_S.code => pushi(i32.truncf(popf()));
					Opcode.I32_TRUNC_SAT_F32_U.code => pushu(u32.truncf(popf()));
					Opcode.I32_TRUNC_SAT_F64_S.code => pushi(i32.truncd(popd()));
					Opcode.I32_TRUNC_SAT_F64_U.code => pushu(u32.truncd(popd()));
					Opcode.I64_TRUNC_SAT_F32_S.code => pushl(i64.truncf(popf()));
					Opcode.I64_TRUNC_SAT_F32_U.code => pushw(u64.truncf(popf()));
					Opcode.I64_TRUNC_SAT_F64_S.code => pushl(i64.truncd(popd()));
					Opcode.I64_TRUNC_SAT_F64_U.code => pushw(u64.truncd(popd()));
					Opcode.MEMORY_INIT.code => {
						var i = frame.func.instance;
						var dindex = codeptr.read_uleb32();
						var ddecl = if(!i.dropped_data[dindex], i.module.data[int.!(dindex)]);
						var mem = i.memories[codeptr.read_uleb32()];
						var size = popu();
						var src_offset = popu();
						var dst_offset = popu();
						var t = mem.copyIn(dst_offset, if(ddecl != null, ddecl.data), src_offset, size);
						if (t != TrapReason.NONE) trap(t);
					}
					Opcode.DATA_DROP.code => {
						var dindex = codeptr.read_uleb32();
						frame.func.instance.dropped_data[dindex] = true;
					}
					Opcode.MEMORY_COPY.code => {
						var i = frame.func.instance;
						var dst = i.memories[codeptr.read_uleb32()];
						var src = i.memories[codeptr.read_uleb32()];
						var size = popu(), src_offset = popu(), dst_offset = popu();
						var t = dst.copyM(dst_offset, src, src_offset, size);
						if (t != TrapReason.NONE) trap(t);
					}
					Opcode.MEMORY_FILL.code => {
						var i = frame.func.instance;
						var mem = i.memories[codeptr.read_uleb32()];
						var size = popu();
						var val = popu();
						var dest = popu();
						var t = mem.fill(dest, u8.view(val), size);
						if (t != TrapReason.NONE) trap(t);
					}
					Opcode.TABLE_INIT.code => {
						var i = frame.func.instance;
						var eindex = codeptr.read_uleb32();
						var elem = if (!i.dropped_elems[eindex], i.module.elems[int.!(eindex)]);
						var table = i.tables[codeptr.read_uleb32()];
						var size = popu();
						var src_offset = popu();
						var dst_offset = popu();
						var t = table.copyE(i, dst_offset, elem, src_offset, size);
						if (t != TrapReason.NONE) trap(t);
					}
					Opcode.ELEM_DROP.code => {
						var index = codeptr.read_uleb32();
						frame.func.instance.dropped_elems[index] = true;
					}
					Opcode.TABLE_COPY.code => {
						var i = frame.func.instance;
						var dst = i.tables[codeptr.read_uleb32()];
						var src = i.tables[codeptr.read_uleb32()];
						var size = popu(), src_offset = popu(), dst_offset = popu();
						var t = dst.copyT(dst_offset, src, src_offset, size);
						if (t != TrapReason.NONE) trap(t);
					}
					Opcode.TABLE_GROW.code => {
						var i = frame.func.instance;
						var table = i.tables[codeptr.read_uleb32()];
						var size = popu();
						var val = pop();
						var r = table.grow(size, val);
						pushi(r);
					}
					Opcode.TABLE_SIZE.code => {
						var i = frame.func.instance;
						var table = i.tables[codeptr.read_uleb32()];
						pushi(table.elems.length);
					}
					Opcode.TABLE_FILL.code => {
						var i = frame.func.instance;
						var table = i.tables[codeptr.read_uleb32()];
						var size = popu();
						var val = pop();
						var dest = popu();
						var t = table.fill(dest, val, size);
						if (t != TrapReason.NONE) trap(t);
					}
					_ => unhandled2(opcode, b2);
				}
			}
			_ => unhandled(opcode);
		}
		if (frame != null) frame.pc = codeptr.pos;
		return 0;
	}
	def unhandled(opcode: byte) {
		if (Opcodes.attributes[opcode].VALID) {
			trap(TrapReason.UNIMPLEMENTED); // better error message than "invalid opcode"
		} else if (Opcodes.attributes[opcode].PREFIX &&
			Opcodes.find(opcode, codeptr.read1()) != Opcode.UNREACHABLE) {
			trap(TrapReason.UNIMPLEMENTED); // better error message than "invalid opcode"
		} else {
			trap(TrapReason.INVALID_OPCODE);
		}
	}
	def unhandled2(opcode: byte, b2: u32) {
		if (Opcodes.find(opcode, b2) != Opcode.UNREACHABLE) {
			trap(TrapReason.UNIMPLEMENTED); // better error message than "invalid opcode"
		} else {
			trap(TrapReason.INVALID_OPCODE);
		}
	}
	def doLoad(load: (Memory, u32, u32) -> (TrapReason, Value)) {
		var flags = codeptr.read1();
		var mem_index = if((flags & BpConstants.MEMARG_INDEX_FLAG) != 0, codeptr.read_uleb32());
		var offset = codeptr.read_uleb32();
		var index = popu();
		var memory = frame.func.instance.memories[mem_index];
		var t = load(memory, offset, index);
		if (t.0 != TrapReason.NONE) trap(t.0);
		else push(t.1);
	}
	def doStore(store: (Memory, u32, u32, Value) -> TrapReason) {
		// XXX: factor load/store logic for better polymorphic specialization
		var flags = codeptr.read1();
		var mem_index = if((flags & BpConstants.MEMARG_INDEX_FLAG) != 0, codeptr.read_uleb32());
		var offset = codeptr.read_uleb32();
		var val = pop();
		var index = popu();
		var memory = frame.func.instance.memories[mem_index];
		var t = store(memory, offset, index, val);
		if (t != TrapReason.NONE) trap(t);
	}
	def do_i32_load(memory: Memory, offset: u32, index: u32) -> (TrapReason, Value) {
		var t = memory.read_u32(offset, index);
		return (t.0, Value.I32(t.1));
	}
	def do_i64_load(memory: Memory, offset: u32, index: u32) -> (TrapReason, Value) {
		var t = memory.read_u64(offset, index);
		return (t.0, Value.I64(t.1));
	}
	def do_f32_load(memory: Memory, offset: u32, index: u32) -> (TrapReason, Value) {
		var t = memory.read_u32(offset, index);
		return (t.0, Value.F32(t.1));
	}
	def do_f64_load(memory: Memory, offset: u32, index: u32) -> (TrapReason, Value) {
		var t = memory.read_u64(offset, index);
		return (t.0, Value.F64(t.1));
	}
	def do_i32_load8_s(memory: Memory, offset: u32, index: u32) -> (TrapReason, Value) {
		var t = memory.read1(offset, index);
		return (t.0, Value.I32(u32.view(i8.view(t.1))));
	}
	def do_i32_load8_u(memory: Memory, offset: u32, index: u32) -> (TrapReason, Value) {
		var t = memory.read1(offset, index);
		return (t.0, Value.I32(t.1));
	}
	def do_i32_load16_s(memory: Memory, offset: u32, index: u32) -> (TrapReason, Value) {
		var t = memory.read_u16(offset, index);
		return (t.0, Value.I32(u32.view(i16.view(t.1))));
	}
	def do_i32_load16_u(memory: Memory, offset: u32, index: u32) -> (TrapReason, Value) {
		var t = memory.read_u16(offset, index);
		return (t.0, Value.I32(t.1));
	}
	def do_i64_load8_s(memory: Memory, offset: u32, index: u32) -> (TrapReason, Value) {
		var t = memory.read1(offset, index);
		return (t.0, Value.I64(u64.view(i8.view(t.1))));
	}
	def do_i64_load8_u(memory: Memory, offset: u32, index: u32) -> (TrapReason, Value) {
		var t = memory.read1(offset, index);
		return (t.0, Value.I64(t.1));
	}
	def do_i64_load16_s(memory: Memory, offset: u32, index: u32) -> (TrapReason, Value) {
		var t = memory.read_u16(offset, index);
		return (t.0, Value.I64(u64.view(i16.view(t.1))));
	}
	def do_i64_load16_u(memory: Memory, offset: u32, index: u32) -> (TrapReason, Value) {
		var t = memory.read_u16(offset, index);
		return (t.0, Value.I64(t.1));
	}
	def do_i64_load32_s(memory: Memory, offset: u32, index: u32) -> (TrapReason, Value) {
		var t = memory.read_u32(offset, index);
		return (t.0, Value.I64(u64.view(i32.view(t.1))));
	}
	def do_i64_load32_u(memory: Memory, offset: u32, index: u32) -> (TrapReason, Value) {
		var t = memory.read_u32(offset, index);
		return (t.0, Value.I64(t.1));
	}
	def do_i32_store(memory: Memory, offset: u32, index: u32, val: Value) -> TrapReason {
		return memory.write_u32(offset, index, Value.I32.!(val).val);
	}
	def do_i64_store(memory: Memory, offset: u32, index: u32, val: Value) -> TrapReason {
		return memory.write_u64(offset, index, Value.I64.!(val).val);
	}
	def do_f32_store(memory: Memory, offset: u32, index: u32, val: Value) -> TrapReason {
		return memory.write_u32(offset, index, Value.F32.!(val).bits);
	}
	def do_f64_store(memory: Memory, offset: u32, index: u32, val: Value) -> TrapReason {
		return memory.write_u64(offset, index, Value.F64.!(val).bits);
	}
	def do_i32_store8(memory: Memory, offset: u32, index: u32, val: Value) -> TrapReason {
		return memory.write_u8(offset, index, u8.view(Value.I32.!(val).val));
	}
	def do_i32_store16(memory: Memory, offset: u32, index: u32, val: Value) -> TrapReason {
		return memory.write_u16(offset, index, u16.view(Value.I32.!(val).val));
	}
	def do_i64_store8(memory: Memory, offset: u32, index: u32, val: Value) -> TrapReason {
		return memory.write_u8(offset, index, u8.view(Value.I64.!(val).val));
	}
	def do_i64_store16(memory: Memory, offset: u32, index: u32, val: Value) -> TrapReason {
		return memory.write_u16(offset, index, u16.view(Value.I64.!(val).val));
	}
	def do_i64_store32(memory: Memory, offset: u32, index: u32, val: Value) -> TrapReason {
		return memory.write_u32(offset, index, u32.view(Value.I64.!(val).val));
	}
	def doFallthru() {
		frame.xip += 4;
	}
	def doBranch(pc: int, cond: bool) -> bool {
		if (cond) {
			codeptr.at(doGoto(pc));
		} else {
			codeptr.skip_label();
			doFallthru();
		}
		return cond;
	}
	def doGoto(pc: int) -> int {
		var xip = frame.xip, sidetable = frame.func.decl.code.sidetable;
		return doCtlXfer(pc, xip, sidetable);
	}
	def doSwitch(pc: int, key: u32) -> int {
		var xip = frame.xip, sidetable = frame.func.decl.code.sidetable;
		var max = sidetable[xip];
		var index = if(key >= max, max, 1 + int.!(key));
		xip += index << 2;
		pc += index;
		return doCtlXfer(pc, xip, sidetable);
	}
	def doCtlXfer(pc: int, xip: int, sidetable: Array<int>) -> int {
		var pc_delta = sidetable[xip];
		var valcount = sidetable[xip + 1];
		var popcount = sidetable[xip + 2];
		var xip_delta = sidetable[xip + 3];
		frame.xip = xip + xip_delta;
		if (popcount > 0) {
			copyVals(valcount, val_stack.top - int.!(popcount + valcount));
		}
		return pc + pc_delta;
	}
	def doReturn() {
		var count = frame.func.decl.sig.results.length;
		copyVals(count, frame.fp);
		call_stack.pop();
		frame = call_stack.peek();
		if (frame == null) {  // popped top frame, finished execution
			E.state = ExecState.FINISHED;
			codeptr.reset(null, 0, 0);
		} else { // advance past caller's call instruction
			var code = frame.func.decl.code.code;
			codeptr.reset(code, frame.pc, code.length);
			var opcode = codeptr.read1();
			match (opcode) {
				Opcode.CALL.code => {
					codeptr.read_uleb32();
				}
				Opcode.CALL_INDIRECT.code => {
					codeptr.read_uleb32();
					codeptr.read_uleb32();
				}
			}
			frame.pc = codeptr.pos;
		}
	}
	def prepareReturnCall(sig: SigDecl) {
		var fp = frame.fp, count = sig.params.length, sp = val_stack.top - count;
		copyVals(count, frame.fp);
		call_stack.pop();
		frame = call_stack.peek();
	}
	def lookupIndirect(sig_index: u32, table_index: u32, func_index: u32) -> Function {
		var instance = frame.func.instance;
		var table = instance.tables[table_index];
		if (func_index >= table.elems.length) {
			trap(TrapReason.FUNC_INVALID);
			return null;
		}
		var expected = instance.sig_ids[sig_index];
		var got = table.ids[func_index];
		if (expected != got) {
			trap(if(got < 0, TrapReason.FUNC_INVALID, TrapReason.FUNC_SIG_MISMATCH));
			return null;
		}
		return table.funcs[func_index];
	}
	def doCallFunction(func: Function) {
		while (true) {  // host function may tail-call another function
			match (func) {
				wf: WasmFunction => return pushFrame(wf);
				hf: HostFunction => {
					var result = doInvokeHostFunction(hf);
					match (result) {
						Trap(reason) => return trap(reason);
						Error(msg) => {
							Execute.error_msg = msg;
							return trap(TrapReason.ERROR);
						}
						Value0 => return;
						Value1(val) => return val_stack.push(val);
						ValueN(vals) => {
							for (a in vals) val_stack.push(a);
							return;
						}
						TailCall(f, args) => {
							func = f;
							for (e in args) val_stack.push(e);
							continue; // execute a tail call to a new function
						}
					}
				}
				_ => return trap(TrapReason.FUNC_INVALID);
			}
		}
	}
	def doInvokeHostFunction(hf: HostFunction) -> HostResult {
		if (Trace.interpreter) Execute.traceCallHostFunction(hf);
		var result: HostResult;
		var count: int, sp: int;
		var elems = val_stack.elems;
		match (hf) {
			hf0: HostFunction0 => {
				count = 0;
				sp = val_stack.top;
				result = hf0.invoke0();
			}
			hf1: HostFunction1 => {
				count = 1;
				sp = val_stack.top - count;
				val_stack.top = sp;
				result = hf1.invoke1(elems[sp]);
			}
			hf2: HostFunction2 => {
				count = 2;
				sp = val_stack.top - count;
				val_stack.top = sp;
				result = hf2.invoke2(elems[sp], elems[sp+1]);
			}
			hf3: HostFunction3 => {
				count = 3;
				sp = val_stack.top - count;
				val_stack.top = sp;
				result = hf3.invoke3(elems[sp], elems[sp+1], elems[sp+2]);
			}
			hfN: HostFunctionN => {
				count = hf.sig.params.length;
				sp = val_stack.top - count;
				val_stack.top = sp;
				var args = Array<Value>.new(count);
				for (i < count) args[i] = elems[sp + i];
				result = hfN.invokeN(args);
			}
		}
		return result;
	}
	def doTruncF32<T>(min: float, max: float, trunc: float -> T, push: T -> ()) {
		var a = popf();
		if (a >= max) return trap(TrapReason.FLOAT_UNREPRESENTABLE);
		if (a <= min) return trap(TrapReason.FLOAT_UNREPRESENTABLE);
		if (!(a == a)) trap(TrapReason.FLOAT_UNREPRESENTABLE);
		push(trunc(a));
	}
	def doTruncF64<T>(min: double, max: double, trunc: double -> T, push: T -> ()) {
		var a = popd();
		if (a >= max) return trap(TrapReason.FLOAT_UNREPRESENTABLE);
		if (a <= min) return trap(TrapReason.FLOAT_UNREPRESENTABLE);
		if (!(a == a)) trap(TrapReason.FLOAT_UNREPRESENTABLE);
		push(trunc(a));
	}
	def trap(reason: TrapReason) {
		E.state = ExecState.TRAPPING;
		frame.pc = codeptr.pos;
		E.resume(E.handleTrap(reason));
	}
	def error(msg: string) {
		E.state = ExecState.TRAPPED;
		E.trap_reason = TrapReason.ERROR;
		E.error_msg = msg;
	}
	def copyVals(count: int, dest: int) {
		var sp = val_stack.top - count;
		if (sp != dest) {
			var e = val_stack.elems;
			for (i < count) e[dest + i] = e[sp + i];
		}
		val_stack.top = dest + count;
	}
	def pop() -> Value { return val_stack.pop(); }
	def popi() -> i32 { return Values.v_i(val_stack.pop()); }
	def popu() -> u32 { return Values.v_u(val_stack.pop()); }
	def popl() -> i64 { return Values.v_l(val_stack.pop()); }
	def popw() -> u64 { return Values.v_w(val_stack.pop()); }
	def popf() -> float { return float.view(Values.v_f(val_stack.pop())); }
	def popd() -> double { return double.view(Values.v_d(val_stack.pop())); }
	def popr() -> Value.Ref { return Value.Ref.!(val_stack.pop()); } // TODO: i31
	def popRtt() -> RttObject { return RttObject.!(Value.Ref.!(val_stack.pop()).val); }
	def push(val: Value) { val_stack.push(val); }
	def pushi(val: i32) { val_stack.push(Value.I32(u32.view(val))); }
	def pushu(val: u32) { val_stack.push(Value.I32(val)); }
	def pushl(val: i64) { val_stack.push(Value.I64(u64.view(val))); }
	def pushw(val: u64) { val_stack.push(Value.I64(val)); }
	def pushf(val: float) { val_stack.push(Value.F32(u32.view(val))); }
	def pushd(val: double) { val_stack.push(Value.F64(u64.view(val))); }
	def pushz(val: bool) { val_stack.push(if(val, Values.I32_1, Values.I32_0)); }
	def popN(count: int) -> Array<Value> {
		var result = Array<Value>.new(count);
		var sp = val_stack.top - count;
		for (i < count) result[i] = val_stack.elems[sp + i];
		val_stack.top = sp;
		return result;
	}
	def traceStep() {
		for (i < call_stack.top) OUT.sp();
		OUT.put1("+%d: ", codeptr.pos);  // XXX: fixed with decimal offset
		var module = if(frame.func.instance != null, frame.func.instance.module);
		var opcode = codeptr.data[codeptr.pos];
		if (instrTracer == null) instrTracer = InstrTracer.new();
		if (opcode == InternalOpcode.PROBE.code) {
			OUT.puts("<probe> ");
			var prev = (codeptr.data, codeptr.pos, codeptr.limit);
			codeptr.reset(frame.func.decl.code.orig, prev.1, prev.2);
			instrTracer.putInstr(OUT, module, codeptr);
			codeptr.reset(prev.0, prev.1, prev.2);
		} else {
			instrTracer.putInstr(OUT, module, codeptr);
		}
		if (Trace.operands) {
			for (i = frame.fp; i < val_stack.top; i++) {
				var v = val_stack.elems[i];
				v.render(OUT.sp());
			}
		}
		OUT.outln();
	}
	def do_dd_d(f: (double, double) -> double) {
		var y = Values.v_d(val_stack.elems[val_stack.top-1]);
		var x = Values.v_d(val_stack.elems[val_stack.top-2]);
		var r = f(double.view(x), double.view(y));
		val_stack.elems[val_stack.top-2] = Value.F64(u64.view(r));
		val_stack.top--;
	}
	def do_ff_f(f: (float, float) -> float) {
		var y = Values.v_f(val_stack.elems[val_stack.top-1]);
		var x = Values.v_f(val_stack.elems[val_stack.top-2]);
		var r = f(float.view(x), float.view(y));
		val_stack.elems[val_stack.top-2] = Value.F32(u32.view(r));
		val_stack.top--;
	}
	def do_dd_z(f: (double, double) -> bool) {
		var y = Values.v_d(val_stack.elems[val_stack.top-1]);
		var x = Values.v_d(val_stack.elems[val_stack.top-2]);
		var r = f(double.view(x), double.view(y));
		val_stack.elems[val_stack.top-2] = if(r, Values.I32_1, Values.I32_0);
		val_stack.top--;
	}
	def do_ff_z(f: (float, float) -> bool) {
		var y = Values.v_f(val_stack.elems[val_stack.top-1]);
		var x = Values.v_f(val_stack.elems[val_stack.top-2]);
		var r = f(float.view(x), float.view(y));
		val_stack.elems[val_stack.top-2] = if(r, Values.I32_1, Values.I32_0);
		val_stack.top--;
	}
	def do_ii_i(f: (i32, i32) -> i32) {
		var y = Values.v_i(val_stack.elems[val_stack.top-1]);
		var x = Values.v_i(val_stack.elems[val_stack.top-2]);
		var r = f(x, y);
		val_stack.elems[val_stack.top-2] = Value.I32(u32.view(r));
		val_stack.top--;
	}
	def do_uu_u(f: (u32, u32) -> u32) {
		var y = Values.v_u(val_stack.elems[val_stack.top-1]);
		var x = Values.v_u(val_stack.elems[val_stack.top-2]);
		var r = f(x, y);
		val_stack.elems[val_stack.top-2] = Value.I32(r);
		val_stack.top--;
	}
	def do_u_u(f: u32 -> u32) {
		var x = Values.v_u(val_stack.elems[val_stack.top-1]);
		var r = f(x);
		val_stack.elems[val_stack.top-1] = Value.I32(r);
	}
	def do_ii_z(f: (i32, i32) -> bool) {
		var y = Values.v_i(val_stack.elems[val_stack.top-1]);
		var x = Values.v_i(val_stack.elems[val_stack.top-2]);
		var r = f(x, y);
		val_stack.elems[val_stack.top-2] = if(r, Values.I32_1, Values.I32_0);
		val_stack.top--;
	}
	def do_uu_z(f: (u32, u32) -> bool) {
		var y = Values.v_u(val_stack.elems[val_stack.top-1]);
		var x = Values.v_u(val_stack.elems[val_stack.top-2]);
		var r = f(x, y);
		val_stack.elems[val_stack.top-2] = if(r, Values.I32_1, Values.I32_0);
		val_stack.top--;
	}
	def do_ll_l(f: (i64, i64) -> i64) {
		var y = Values.v_l(val_stack.elems[val_stack.top-1]);
		var x = Values.v_l(val_stack.elems[val_stack.top-2]);
		var r = f(x, y);
		val_stack.elems[val_stack.top-2] = Value.I64(u64.view(r));
		val_stack.top--;
	}
	def do_ww_w(f: (u64, u64) -> u64) {
		var y = Values.v_w(val_stack.elems[val_stack.top-1]);
		var x = Values.v_w(val_stack.elems[val_stack.top-2]);
		var r = f(x, y);
		val_stack.elems[val_stack.top-2] = Value.I64(r);
		val_stack.top--;
	}
	def do_w_w(f: u64 -> u64) {
		var x = Values.v_w(val_stack.elems[val_stack.top-1]);
		var r = f(x);
		val_stack.elems[val_stack.top-1] = Value.I64(r);
	}
	def do_ll_z(f: (i64, i64) -> bool) {
		var y = Values.v_l(val_stack.elems[val_stack.top-1]);
		var x = Values.v_l(val_stack.elems[val_stack.top-2]);
		var r = f(x, y);
		val_stack.elems[val_stack.top-2] = if(r, Values.I32_1, Values.I32_0);
		val_stack.top--;
	}
	def do_ww_z(f: (u64, u64) -> bool) {
		var y = Values.v_w(val_stack.elems[val_stack.top-1]);
		var x = Values.v_w(val_stack.elems[val_stack.top-2]);
		var r = f(x, y);
		val_stack.elems[val_stack.top-2] = if(r, Values.I32_1, Values.I32_0);
		val_stack.top--;
	}
	def do_f_f(f: float -> float) {
		var x = Values.v_f(val_stack.elems[val_stack.top-1]);
		var r = f(float.view(x));
		val_stack.elems[val_stack.top-1] = Value.F32(u32.view(r));
	}
	def do_d_d(f: double -> double) {
		var x = Values.v_d(val_stack.elems[val_stack.top-1]);
		var r = f(double.view(x));
		val_stack.elems[val_stack.top-1] = Value.F64(u64.view(r));
	}
	def signExtend(st: StorageType, val: Value) -> Value {
		match (st.packing) {
			PACKED_I8 => return Value.I32(u32.view(i8.view(Values.v_i(val))));
			PACKED_I16 => return Value.I32(u32.view(i16.view(Values.v_i(val))));
			_ => return val;
		}
	}
	def zeroExtend(st: StorageType, val: Value) -> Value {
		match (st.packing) {
			PACKED_I8 => return Value.I32(u8.view(Values.v_i(val)));
			PACKED_I16 => return Value.I32(u16.view(Values.v_i(val)));
			_ => return val;
		}
	}
}

def SYNTH_CODE = Code.new([
	0, // no locals
	InternalOpcode.START.code,
	Opcode.END.code
]);
